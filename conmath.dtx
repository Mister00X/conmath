% \iffalse meta-comment
%
% Copyright (C) 2024 Marcel Ilg
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%
%      https://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status ‘maintained’.
%
% The Current Maintainer of this work is Marcel Ilg.
%
% This work consists of the files listed in MANIFEST.md.
% \fi
%
% \iffalse
%
%<*driver>
% Generated by ctanbib
\begin{filecontents*}[overwrite]{\jobname.bib}
@preamble{ "\providecommand\ctanbibpkgname[1]{\textsl{#1}}" }
@manual{amsmath,
  title = {The \ctanbibpkgname{amsmath} package},
  subtitle = {AMS mathematical facilities for LaTeX},
  author = {{The LaTeX Project Team}},
  url = {https://ctan.org/pkg/amsmath},
  urldate = {2024-06-08},
  date = {2023-05-13},
  version = {2.17o},
}

@preamble{ "\providecommand\ctanbibpkgname[1]{\textsl{#1}}" }
@manual{bm,
  title = {The \ctanbibpkgname{bm} package},
  subtitle = {Access bold symbols in maths mode},
  author = {Carlisle, David and Mittelbach, Frank and {The LaTeX Project Team}},
  url = {https://ctan.org/pkg/bm},
  urldate = {2024-06-08},
  date = {2023-12-19},
  version = {1.2f},
}

@preamble{ "\providecommand\ctanbibpkgname[1]{\textsl{#1}}" }
@manual{mathtools,
  title = {The \ctanbibpkgname{mathtools} package},
  subtitle = {Mathematical tools to use with amsmath},
  author = {Høgholm, Morten and Madsen, Lars and Robertson, Will and Wright, Joseph and {The LaTeX Project Team}},
  url = {https://ctan.org/pkg/mathtools},
  urldate = {2024-06-08},
  date = {2024-03-11},
  version = {1.30},
}
\end{filecontents*}
\begin{filecontents*}[overwrite]{\jobname-ams-op-table.tex}
\begin{tabular}{rlrlrlrl}
  \cs[module=amsmath,replace=false]{arccos} &\(\arccos\)  &\cs[module=amsmath,replace=false]{deg}    &\( \deg \)  &\cs[module=amsmath,replace=false]{lg}      &\( \lg \)      &\cs[module=amsmath,replace=false]{projlim} &\( \projlim \)\\
  \cs[module=amsmath,replace=false]{arcsin} &\(\arcsin\)  &\cs[module=amsmath,replace=false]{det}    &\( \det \)  &\cs[module=amsmath,replace=false]{lim}     &\( \lim \)     &\cs[module=amsmath,replace=false]{sec}     &\( \sec \)\\
  \cs[module=amsmath,replace=false]{arctan} &\(\arctan\)  &\cs[module=amsmath,replace=false]{dim}    &\( \dim \)  &\cs[module=amsmath,replace=false]{liminf}  &\( \liminf \)  &\cs[module=amsmath,replace=false]{sin}     &\( \sin \)\\
  \cs[module=amsmath,replace=false]{arg}    &\(\arg\)     &\cs[module=amsmath,replace=false]{exp}    &\( \exp \)  &\cs[module=amsmath,replace=false]{limsup}  &\( \limsup \)  &\cs[module=amsmath,replace=false]{sinh}    &\( \sinh \)\\
  \cs[module=amsmath,replace=false]{cos}    &\(\cos\)     &\cs[module=amsmath,replace=false]{gcd}    &\( \gcd \)  &\cs[module=amsmath,replace=false]{ln}      &\( \ln \)      &\cs[module=amsmath,replace=false]{sup}     &\( \sup \)\\
  \cs[module=amsmath,replace=false]{cosh}   &\(\cosh\)    &\cs[module=amsmath,replace=false]{hom}    &\( \hom \)  &\cs[module=amsmath,replace=false]{log}     &\( \log \)     &\cs[module=amsmath,replace=false]{tan}     &\( \tan \)\\
  \cs[module=amsmath,replace=false]{cot}    &\(\cot\)     &\cs[module=amsmath,replace=false]{inf}    &\( \inf \)  &\cs[module=amsmath,replace=false]{max}     &\( \max \)     &\cs[module=amsmath,replace=false]{tanh}    &\( \tanh \)\\
  \cs[module=amsmath,replace=false]{coth}   &\(\coth\)    &\cs[module=amsmath,replace=false]{injlim} &\(\injlim\) &\cs[module=amsmath,replace=false]{min}     &\( \min \)     &                       &\\
  \cs[module=amsmath,replace=false]{csc}    &\(\csc\)     &\cs[module=amsmath,replace=false]{ker}    &\(\ker\)    &\cs[module=amsmath,replace=false]{Pr}      &\( \Pr \)      &                       &\\
\end{tabular}
\begin{center}
  \begin{tabular}{rlrl}
    \cs[module=amsmath,replace=false]{varinjlim}  &\(\varinjlim\)   &\cs[module=amsmath,replace=false]{varliminf} &\(\varliminf\)\\
    \cs[module=amsmath,replace=false]{varprojlim} &\(\varprojlim\)  &\cs[module=amsmath,replace=false]{varlimsup} &\(\varlimsup\)\\
  \end{tabular}
\end{center}
\end{filecontents*}


% custom commands for use inside the documentation
\ExplSyntaxOn
% Property list storing version date information
\prop_new:N \l__conmathdoc_version_date_prop

\cs_new_protected:Nn \conmathdoc_add_version:nn
{
  \prop_put_if_new:Nnn \l__conmathdoc_version_date_prop {#1} {#2}
}

\cs_new_protected:Nn \conmathdoc_get_version:n
{
  \group_begin:
  \prop_get:NnNT \l__conmathdoc_version_date_prop {#1} \l_tmpa_tl
  {
    \tl_use:N \l_tmpa_tl
  }
  \group_end:
}

\NewDocumentCommand \AddVersion { m m }
{
  \conmathdoc_add_version:nn {#1} {#2}
}

\NewDocumentCommand \GetVersionDate { m }
{
  \conmathdoc_get_version:n {#1}
}
\ExplSyntaxOff

\documentclass[show-notes]{l3doc}

\SetupDoc{reportchangedates=true}
\RecordChanges

\usepackage[american]{babel}
\AddBabelHook[american]{nofrench}{afterextras}{\frenchspacing}

\usepackage[style=alphabetic]{biblatex}
\addbibresource{\jobname.bib}

\usepackage{csquotes}
\SetCiteCommand{\autocite}

\usepackage[bm]{conmath}

% renew the ctanbibpkgname command
\NewDocumentCommand\ctanbibpkgname{m}{\pkg{#1}}

% Example operators and commands
\DeclareMathOperator{\glorb}{glorb}
\DeclarePairedDelimiter{\inparen}{\lparen}{\rparen}
\DeclareDelimitedOperator{\pglorb}{\glorb}{\inparen}

\begin{document}
  \DocInput{conmath.dtx}
\end{document}
%</driver>
% \fi
%
% ^^X Get the package version name etc.
% \GetFileInfo{conmath.sty}
%
% ^^X Register changes here
% \AddVersion{vUNRELEASED}{UNRELEASED}
% \changes{vUNRELEASED}{\GetVersionDate{vUNRELEASED}}{Initial development release}
%
% \title{The \pkg{conmath} package\thanks{This document coresponds to
%   \textsf{conmath}~\fileversion, dated \filedate.}}
% \author{Marcel Ilg\thanks{\texttt{mister01x (at) web (dot) de}}}
% \date{Released \filedate}
%
% \maketitle
% \begin{abstract}
% \end{abstract}
% \tableofcontents
% \begin{documentation}
% \section{Introduction}
% \label{sec:intro}
%
%
% \section{Package Options}
% \label{sec:pack-opts}
%
% ^^X SUBSECTION: Package Load Time Options
% \subsection{Package Load Time Options}
% \label{sec:pkg-load-time-opts}
% The options described in this section \emph{must} be given
% at package load time i.e.\ as package options.
% All options which are not described below will be passed to
% \pkg{mathtools}~\autocite{mathtools},
% see its documentation for more information.
%
% \DescribeOption{bm} The \verb|bm| option
% loads the \pkg{bm}~\autocite{bm} package which provides a better version of
% the \cs{boldsymbol} command.
%
% \DescribeOption{no-vector}
% \DescribeOption{no-abs-shorthands}
% \DescribeOption{no-operators}
% \NB{MI}{Missing: no-crvector and no-matrix}
% The options \verb|no-vector|, \verb|no-abs-shorthands| and \verb|no-operators|
% disable the definition of the predefined commands described in sections~\ref{sec:vector-calculus},
% \ref{sec:shorthands} and~\ref{sec:delim-ops} respectively.
%
% \DescribeOption{nopredef}
%   The option |nopredef| achieves the same as the three
%   |no-|\meta{functionality} options above.
%   It accepts multiple values, valid option values are: |vector|, |abs|,
%   |operators| and |all|.
%   The values |abs|, |operators|, and |vector| disable the predefined
%   document level commands for delimited operators, vector calculus and
%   the shorthands for absolute value and norm respectively.
%   The special value |all| disables all of them.
%
%   The option accepts multiple values which can be given as a comma separated
%   list, or as multiple key-value options, like in the examples below:
% \begin{verbatim}
% \usepackage[nopredef={vector,abs,operators}]{conmath}
% \end{verbatim}
%   This is equivalent to
% \begin{verbatim}
% \usepackage[nopredef=all]{conmath}
% \end{verbatim}
%   and to:
% \begin{verbatim}
% \usepackage[nopredef=vector,nopredef=abs,nopredef=operators]{conmath}
% \end{verbatim}
%
% The command \cs{NewDelimitedOperator} is not affected by any of the above
% settings.
%
% ^^X SUBSECTION: General Options
% \subsection{General Options}
% \label{sec:pkg-general-options}
%
% The options described in this section
% \emph{must not} be given as package options,
% instead they should be set using \cs{conmathsetup}
% or given as optional argument to the commands described later.
% \begin{function}{\conmathsetup}
% \begin{syntax}
%   \cs{conmathsetup}\marg{kv~list}
% \end{syntax}
% Sets the options specified in the \meta{key-value list},
% the assignment is local to the current group.
% If a \meta{value} contains a comma it needs to be wrapped in braces.
% This command may be used anywhere in the document after \pkg{conmath}
% has been loaded.
% \end{function}
%
% \subsubsection{Options Affecting Vector Calculus Operators}
% \label{sec:options-vec-calc}
%
% \DescribeOption{nabla}
% The option |nabla| sets the symbol to use by the document level commands
% described in section~\ref{sec:vector-calculus} to use for the nabla.
% It accepts a list of \meta{tokens}. Its default value is |\nabla|.
%
% \DescribeOption{arrownabla}
% The option |arrownabla| puts a small arrow over the gradient operator symbol.
% Its default value is |false|.
%
% \DescribeOption{boldnabla}
% The option |boldnabla| makes the nabla symbol bold.
% If the |bm| package option has been given the |\boldsymbol| command from
% the \pkg{bm} package is used for the bold symbol,
% otherwise the \pkg{amsmath}~\autocite{amsmath} version is used.
%
% \DescribeOption{grad-op}
% The option |grad-op| may be used to overwrite,
% the built in version of the gradient operator, it accepts a \meta{token list}.
% Use at your own responsibility.
%
% \DescribeOption{laplacian-symb}
% The option |laplacian-symb| sets the symbol to use by the document level
% commands described in section~\ref{sec:vector-calculus} to use for the
% Laplace operator. It accepts a list of \meta{tokens}.
%
% \DescribeOption{delta-laplace}
% The option |delta-laplace| replaces the Laplace operator symbol
% (by default \(\laplacian\)) with a uppercase delta
% (\(\laplacian[delta-laplace=true]\)).
% Its default value is |false|.
%
% \DescribeOption{arrowlaplace}
% The option |arrowlaplace| if set to |true| makes the Laplace operator look
% like this: \(\laplacian[arrowlaplace=true]\).
%
% \DescribeOption{laplacian}
% Like the option |grad-op| above the option |laplacian| may be used to
% overwrite the built-in version of the Laplace operator.
% Use at your own responsibility.
%
% \subsubsection{Options Affecting Matrices and Vectors}
% \label{sec:options-matrix}
%
% The options in this section only affect the commands described in sections~\ref{sec:rc-vectors}
% and~\ref{sec:matrices}. To set them with \cs{conmathsetup} it is necessary
% to add the prefix |matrix / | to these options,
% so that the resulting command looks like \cs{conmathsetup}\texttt{\{matrix / \meta{option}\}}.
% When using these options inside the optional argument of the commands described
% in sections~\ref{sec:rc-vectors} and~\ref{sec:matrices}, the prefix "matrix /"
% must be omitted.
%
% \DescribeOption{delimiter}
% The option |delimiter| determines the delimiters used for the matrices,
% valid values are "p" for parenthesis, "b" for brackets, "B" for braces,
% "v" for single vertical lines (\enquote{\(\vert\)}),
% "V" for double vertical lines (\enquote{\(\Vert\)}) or empty for no delimiters.
% The default value is "{}" (empty).
%
% \DescribeOption{fill}
% The fill option determines the values an (anti-)diagonal matrix is filled with,
% outside the diagonal. The default is again empty.
%
% \DescribeOption{align}
% This option determines the alignment of the numbers inside the matrix.
% The value of this option gets passed to the optional argument of the \env{matrix*}
% or \env{smallmatrix*} family of environments defined by \pkg{mathtools}~\autocite{mathtools}.
% Valid values for both types of those environments are |l| for left alignment,
% |r| for right alignment and |c| for centered alignment. The default is |c|.
%
% \begin{texnote}
%   The non-"small" versions of the commands described in the sections~\ref{sec:rc-vectors}
%   and~\ref{sec:matrices}, accept \textcquote{mathtools}{\textelp{}
%   any column type valid in the usual \env{array} environment.}
% \end{texnote}
%
%
% \section{Delimited Operators}
% \label{sec:delim-ops}
%
% \subsection{Delimited Operators Predefined by \pkg{conmath}}
% \label{sec:delim-op-predef}
%
% \DescribeOption{no-operators}
% If the package load time option |no-operators| is not given this package defines several
% delimited mathematical operators.
%
% \begin{table}
%   \caption{%
%     Operator commands defined by the \pkg{amsmath}~\autocite{amsmath}
%     package.}
%  \label{tab:amsmath-operators}
%  \vspace{.5\baselineskip}
%   \input{\jobname-ams-op-table.tex}
% \end{table}
%
% \begin{function}{
%   \parccos, \barccos, \Barccos, \varccos, \Varccos,
% }
% \begin{syntax}
%   \cs{parccos} \oarg{size cmd} \marg{contents}

%   \cs{parccos} \oarg{size cmd} \textasciicircum\marg{superscript} \marg{contents}
%
%   \cs{parccos} \oarg{size cmd} \_\marg{subscript} \marg{contents}
%
%   \cs{parccos} \oarg{size cmd} \textasciicircum\marg{superscript} \_\marg{subscript} \marg{contents}
%
%   \cs{parccos}* \marg{contents}
%
%   \cs{parccos}* \textasciicircum\marg{superscript} \marg{contents}
%
%   \cs{parccos}* \_\marg{subscript} \marg{contents}
%   \cs{parccos}* \textasciicircum\marg{superscript} \_\marg{subscript} \marg{contents}
%
%
%   \cs[no-index]{\meta{prefix}\meta{op name}} \oarg{size cmd} \marg{contents}
%   \cs[no-index]{\meta{prefix}\meta{op name}} \oarg{size cmd} \textasciicircum\marg{superscript}  \marg{contents}
%   \cs[no-index]{\meta{prefix}\meta{op name}} \oarg{size cmd}  \_\marg{subscript} \marg{contents}
%   \cs[no-index]{\meta{prefix}\meta{op name}} \oarg{size cmd} \textasciicircum\marg{superscript} \_\marg{subscript} \marg{contents}
%   \cs[no-index]{\meta{prefix}\meta{op name}}* \marg{contents}
%   \cs[no-index]{\meta{prefix}\meta{op name}}* \textasciicircum\marg{superscript}  \marg{contents}
%   \cs[no-index]{\meta{prefix}\meta{op name}}* \_\marg{subscript} \marg{contents}
%   \cs[no-index]{\meta{prefix}\meta{op name}}* \textasciicircum\marg{superscript} \_\marg{subscript} \marg{contents}
% \end{syntax}
% For all of the operators predefined by \pkg{amsmath}~\autocite{amsmath},
% which are shown in table~\ref{tab:amsmath-operators},
% \pkg{conmath} declares delimited versions.
% The name of those commands follows the scheme \cs[no-index]{\meta{prefix}\meta{op}},
% where \meta{prefix} is one of |p|, |b|, |B|, |v|, or |V|
% and \meta{op} is the name of one of the operators shown in table~\ref{tab:amsmath-operators}.
%
% The \meta{prefix}es |p|, |b|, |B|, |v|, and |V| stand for
% parenthesis, brackets, braces, single vertical lines (\enquote{\(\vert\)}), and double vertical lines
% (\enquote{\(\Vert\)}) respectively.
%
% The commands accept a \meta{size cmd} optional argument, which is usually one of
% \cs{big}, \cs{Big}, \cs{bigg} and \cs{Bigg}.
% These \meta{size cmd}s are used to change the size of the delimiters.
%
% The commands also accept sub- and superscripts,
% which have to be issued \emph{after} the optional argument (if present),
% but before the mandatory argument \meta{contents}.
%
% The starred variant uses automatic scaling for the delimiters depending on the height of its contents.
% \end{function}
%
% \paragraph{Examples}
%
% The following examples showcase the use of those predefined delimited operators:
% \begin{enumerate}
% \item Different delimited operators without any scaling:
%
% \begin{verbatim}
% \[
%   \pcos{x} \times \bcos{y}
%   \times \Bcos{z} \times \vcos{a}
%   \times \Vcos{b}
% \]
% \end{verbatim}
% \[
%   \pcos{x} \times \bcos{y}
%   \times \Bcos{z} \times \vcos{a}
%   \times \Vcos{b}
% \]
%
% \item Delimited operator with automatic scaling:
%
% \begin{minipage}{.49\linewidth}
% \begin{verbatim}
% \[
%   \pcos*{\frac{x^{2}}{2}}
% \]
% \end{verbatim}
% \end{minipage}\hfill
% \begin{minipage}{.49\linewidth}
% \[
%     \pcos*{\frac{x^{2}}{2}}
%  \]
% \end{minipage}
%
% \item Delimited operator with manual scaling:
%
% \begin{minipage}{.49\linewidth}
% \begin{verbatim}
% \[
%   \pcos[\Big]{\frac{x^{2}}{2}}
% \]
% \end{verbatim}
% \end{minipage}\hfill
% \begin{minipage}{.49\linewidth}
% \[
%   \pcos[\Big]{\frac{x^{2}}{2}}
% \]
% \end{minipage}
%
% \item Delimited operator with subscript:
%
% \begin{minipage}{.49\linewidth}
% \begin{verbatim}
% \[
%   \plog_{10}{1+x}
% \]
% \end{verbatim}
% \end{minipage}\hfill
% \begin{minipage}{.49\linewidth}
% ^^X XXX: Using an underscore is broken here (because of l3doc???) therefore I
% ^^X use "\sb" instead.
% \[
%   \plog\sb{10}{1+x}
% \]
% \end{minipage}
%
% \item Delimited operator with superscript:
%
% \begin{minipage}{.49\linewidth}
% \begin{verbatim}
% \[
%   \pcos^{2}{x}
% \]
% \end{verbatim}
% \end{minipage}\hfill
% \begin{minipage}{.49\linewidth}
% \[
%   \pcos^{2}{x}
% \]
% \end{minipage}
%
% \item Delimited operator with both sub- and superscript and manual scaling:
%
% \begin{minipage}{.49\linewidth}
% \begin{verbatim}
% \[
%   \pcos[\Big]^{2}_{x}{\frac{x}{2}}
% \]
% \end{verbatim}
% \end{minipage}\hfill
% \begin{minipage}{.49\linewidth}
% ^^X XXX: Again use "\sb" instead of "_" because of l3doc
% \[
%   \pcos[\Big]^{2}\sb{x}{\frac{x}{2}}
% \]
% \end{minipage}
% \end{enumerate}
%
%
% \subsection{Declaring New Delimited Operators}
% \label{sec:delim-op-new}
%
% \begin{function}{\DeclareDelimitedOperator}
% \begin{syntax}
%   \cs{DeclareDelimitedOperator}\marg{new op}\marg{op}\marg{delim}
% \end{syntax}
% Creates a new delimited operator,
% the name of the new command will be \meta{new op}.
% The \meta{op} is the command of the operator to use,
% which is usually a command declared with
% \cs[module=amsmath,replace=false]{DeclareMathOperator}.
% \meta{delim} is the command to use as paired delimiter,
% it is expected to behave like a paired delimiter declared by
% \pkg{mathtools}~\autocite{mathtools}
% \cs[module=mathtools,replace=false]{DeclarePairedDelimiter}.
% \end{function}
%
% \paragraph{Example: Creating a New Delimited Operator}
% The following code creates a new operator and a paired delimiter
% and uses it afterwards to declare a paired operator.
% \begin{verbatim}
% \documentclass{scrartcl}
%
% \DeclareMathOperator{\glorb}{glorb}
% \DeclarePairedDelimiter{\inparen}{\lparen}{\rparen}
% \DeclarePairedOperator{\pglorb}{\glorb}{\inparen}
%
% \begin{document}
% \[
%   \pglorb{a}
% \]
% \end{document}
% \end{verbatim}
% The result then looks like this:
% \[
%   \pglorb{a}
% \]
% \end{documentation}
% \begin{implementation}
% \section{Implementation}
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Set the internal prefix for this package so that \pkg{DocStrip} knows what to
% do.
%    \begin{macrocode}
%<@@=conmath>
%    \end{macrocode}
%
% \subsection{Initial Setup}
%
% First set the required version of \LaTeX{},
% we need at least
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2022-06-01]
%    \end{macrocode}
% for key-value option handling, \pkg{xparse}-like document commands
% and hooks.
%
% Then identify this package as \pkg{conmath}.
%    \begin{macrocode}
\ProvidesExplPackage{conmath}
  {UNRELEASED}{UNRELEASED}{Convenience Math Macros}

%    \end{macrocode}
%
% ^^X Debugging switch
% \iffalse
% \debug_on:n {}
% \fi
% \subsection{Key-value interfaces}
% \label{sec:key-val}
% To make use of key-value interfaces we need to define a few keys.
%
% \subsubsection{Package load time options}
% \label{sec:load-time-options}
%
% To allow for the conditional definition of macros at load time
% we define a few keys.
%
% But before doing so we define a few messages to write the package options to
% the log file.
% One message to issue if the \texttt{bm} option has been given:
%    \begin{macrocode}
\msg_new:nnn { conmath } {load / bm}
{
  Option~'bm'~given.\\
  Loading~the~bm~package~\msg_line_context:.
}
%    \end{macrocode}
% And a more generic message to issue for the other options,
% which all disable certain parts of the library.
%    \begin{macrocode}
\msg_new:nnn {conmath} { load / disabling }
{
  Option~'#1'~given.\\
  Disabling~#2~\msg_line_context:.
}
%    \end{macrocode}
% \begin{optionenv}{
%   bm,
%   no-vector,
%   no-operators,
%   no-abs-shorthands,
%   no-matrix,
%   no-crvector,
%   nopredef,
% }
% Now we define package load time keys:
%    \begin{macrocode}
\keys_define:nn { conmath / load }
{
%    \end{macrocode}
% We provide an option to conditionally load the \pkg{bm}-package~\autocite{bm}
% to provide better looking bold symbols.
%    \begin{macrocode}
  bm .code:n = {
    \msg_info:nn {conmath} {load / bm}
    \RequirePackage{bm}
  },
  bm .value_forbidden:n = true,
  bm. usage:n = load,
%    \end{macrocode}
% \begin{variable}{
%   \l_@@_predef_vector_op_bool,
%   \l_@@_predef_operators_bool,
%   \l_@@_predef_crvector_bool,
%   \l_@@_predef_matrix_bool,
%   \l_@@_predef_abs_bool,
% }
% Then we define options for en-/disabling predefined macros of this package
% to avoid name clashes.
%    \begin{macrocode}
  no-vector .bool_set_inverse:N = \l_@@_predef_vector_op_bool,
  no-vector .default:n = true,
  no-vector .initial:n = false,
  no-vector .usage:n = load,
  no-operators .bool_set_inverse:N = \l_@@_predef_operators_bool,
  no-operators .default:n = true,
  no-operators .initial:n = false,
  no-operators .usage:n = load,
  no-abs-shorthands .bool_set_inverse:N = \l_@@_predef_abs_bool,
  no-abs-shorthands .default:n = true,
  no-abs-shorthands .initial:n = false,
  no-abs-shorthands .usage:n = load,
  no-matrix .bool_set_inverse:N = \l_@@_predef_matrix_bool,
  no-matrix .initial:n = false,
  no-matrix .default:n = true,
  no-matrix .usage:n =load,
  no-crvector .bool_set_inverse:N = \l_@@_predef_crvector_bool,
  no-crvector .default:n = true,
  no-crvector .initial:n = false,
  no-crvector .usage:n = load,
%    \end{macrocode}
% The variables \cs{l_@@_predef_vector_op_bool}, \cs{l_@@_predef_operators_bool}
% \cs{l_@@_predef_abs_bool}, \cs{l_@@_predef_matrix_bool}
% and \cs{l_@@_predef_crvector_bool}
% control if the predefined macros
% for vector calculus, delimited operators, the matrix shorthands,
% the row and column vectors,
% and the shorthands for absolute value
% and norm shall be defined.
% \end{variable}
%    \begin{macrocode}
  nopredef .multichoice:,
  nopredef / operators .meta:nn = { conmath / load }
  {
    no-operators = true
  },
  nopredef / vector .meta:nn = { conmath / load }
  {
    no-vector = true
  },
  nopredef / abs .meta:nn = { conmath / load }
  {
    no-abs-shorthands = true,
  },
  noperdef / matrix .meta:nn = { conmath / load }
  {
    no-matrix = true,
  },
  nopredef / crvector .meta:nn = {conmath / load}
  {
    no-crvector = true,
  },
  nopredef / all .meta:nn = { conmath / load }
  {
    no-operators = true,
    no-vector = true,
    no-abs-shorthands = true
  },
  nopredef .usage:n = load,
%    \end{macrocode}
% Unknown package options get passed to \pkg{mathtools}.
%    \begin{macrocode}
  unknown .code:n = {\PassOptionsToPackage{\CurrentOption}{mathtools}},
  unknown .usage:n = load,
}
%    \end{macrocode}
% \end{optionenv}
%
%
% \subsubsection{Keys controlling appearance}
% \label{sec:keys-appearance}
%
% \begin{optionenv}{
%   nabla,
%   arrownabla,
%   boldnabla,
%   grad-op,
%   laplacian-symb,
%   delta-laplace,
%   arrowlaplace,
%   laplacian
% }
% First define keys for the vector calculus macros.
%    \begin{macrocode}
\keys_define:nn { conmath }
{
%    \end{macrocode}
% First we define keys for use with the gradient and gradient based operators.
% \begin{variable}{
%   \l_@@_nabla_tl,
%   \l_@@_nabla_arrow_bool,
%   \l_@@_nabla_arrow_bold_bool,
%   \l_@@_grad_op_tl,
% }
%    \begin{macrocode}
  % Symbol to use for the nabla
   nabla .tl_set:N = \l_@@_nabla_tl,
   nabla .initial:n = {\nabla},
   nabla .value_required:n = true,
   % shall the nabla have an arrow over it
   arrownabla .bool_set:N = \l_@@_nabla_arrow_bool,
   arrownabla .default:n = {true},
   arrownabla .initial:n = {false},
   % shall the nabla be bold
   boldnabla .bool_set:N = \l_@@_nabla_bold_bool,
   boldnabla .default:n = {true},
   boldnabla .initial:n = {false},
%    \end{macrocode}
% The symbol to use as \enquote{nabla} is stored in \cs{l_@@_nabla_tl}.
% The variables \cs{l_@@_nabla_arrow_bool} and \cs{l_@@_nabla_bold_bool}
% determine if the nabla-symbol shall have an arrow over itself and/or be bold
% respectively.
%
% We also provide an override for the gradient operator
%    \begin{macrocode}
   % Symbol to use for the gradient operator
   grad-op .tl_set:N = \l_@@_grad_op_tl,
   grad-op .value_required:n = true,
%    \end{macrocode}
% The variable \cs{l_@@_grad_op_tl} contains a user provided token list to
% overwrite the built-in gradient operator of the package.
% \end{variable}
%
% \begin{variable}{
%   \l_@@_laplacian_symb_tl,
%   \l_@@_laplacian_delta_bool,
%   \l_@@_laplacian_arrow_bool,
%   \l_@@_laplacian_tl,
% }
% Then we define keys for the laplacian.
%    \begin{macrocode}
   % Symbol to use for the laplacian
   laplacian-symb .tl_set:N = \l_@@_laplacian_symb_tl,
   laplacian-symb .initial:n = {\l_@@_nabla_tl},
   % shall the Laplace operator be a delta
   delta-laplace .bool_set:N = \l_@@_laplacian_delta_bool,
   delta-laplace .initial:n = {false},
   % shall the laplace operator have an arrow over itself
   arrowlaplace .bool_set:N = \l_@@_laplacian_arrow_bool,
   arrowlaplace .default:n = {true},
   arrowlaplace .initial:n = {false},
   % overwrite the laplace operator
   laplacian .tl_set:N = \l_@@_laplacian_tl,
   laplacian .value_required:n = true,
}
%    \end{macrocode}
% The token list variable \cs{l_@@_laplacian_symb_tl} stores the tokens to be
% used for the Laplace operator.
% The boolean variable \cs{l_@@_laplacian_delta_bool}
% determines if a delta should be used instead
% of \(\laplacian\) for the laplacian symbol.
% If the boolean variable \cs{l_@@_laplacian_arrow_bool} a small arrow will be
% placed over the Laplace operator symbol.
% If the user wants to overwrite the symbol used for the Laplacian,
% the user provided list of tokens is stored in the variable
% \cs{l_@@_laplacian_tl}.
% \end{variable}
% \end{optionenv}
%
% \begin{optionenv}{
%   delimiter,
%   fill,
%   align
% }
% Then we define some keys for the matrix based environments:
%    \begin{macrocode}
\keys_define:nn { conmath / matrix }
{
%    \end{macrocode}
% \begin{variable}{
% \l_@@_matrix_delim_tl,
% \l_@@_matrix_fill_tl,
% \l_@@_matrix_align_tl,
% }
% Every one of the following keys stores its value inside a token list variable.
%    \begin{macrocode}
  delimiter .tl_set:N = \l_@@_matrix_delim_tl,
  delimiter .initial:n = {},
  fill .tl_set:N = \l_@@_matrix_fill_tl,
  fill .initial:n = {},
  align .tl_set:N = \l_@@_matrix_align_tl,
  align .initial:n = {c},
  align .value_required:n = true,
}
%    \end{macrocode}
% The keys \verb|delimiter| and \verb|fill| set the variables
% \cs{l_@@_matrix_delim_tl} and \cs{l_@@_matrix_fill_tl} respectively.
% \cs{l_@@_matrix_delim_tl} determines the delimiter in use to surround
% matrices and \cs{l_@@_matrix_fill_tl} determines the fill values of the
% \cs{diag}, \cs{smalldiag}, \cs[no-index]{Xdiag} and \cs[no-index]{Xsmalldiag}
% commands, which are used for non-diagonal matrix entries.
% The variable \cs{l_@@_matrix_align_tl} contains the alignment specifier
% for use with the \env{matrix*} environment.
% \end{variable}
% \end{optionenv}
%
% \subsubsection{Functions for Setting Options}
% \label{sec:option-setters}
%
%
% Now we define a function for setting the options within the document
% \begin{macro}{\conmath_setup:n}
%    \begin{macrocode}
\cs_new_protected:Nn \conmath_setup:n
{
  \keys_set:nn {conmath} {#1}
}
%    \end{macrocode}
% \end{macro}
%
% Additionally we provide the user with a version of this command.
% \begin{macro}{\conmathsetup}
%    \begin{macrocode}
\NewDocumentCommand \conmathsetup {m}
{
  \conmath_setup:n {#1}
}
%    \end{macrocode}
% \end{macro}
% We also need a function for setting the package load time options.
% This function should set all given values for all key families
% and pass unknown options to mathtools.
% \begin{macro}{\@@_load_time_setup:}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_load_time_setup:
{
  \ProcessKeyOptions[ conmath / load ]
}
%    \end{macrocode}
% \end{macro}
%
% ^^X SUBSECTION: Package Initialization
% \subsection{Package Initialization}
% \label{sec:init}
%
% We now \enquote{initialize} the package by processing the package options,
% all unknown options are passed to \pkg{mathtools}~\autocite{mathtools},
% which is loaded afterwards.
% Because certain \pkg{mathtools}-features are needed by this package,
% we need to require a version of at least 2004/06/05.
% As explained in section~\ref{sec:load-time-options} this may also load \pkg{bm}
% if the \verb|bm| package option has been given.
%    \begin{macrocode}
\@@_load_time_setup:

\RequirePackage{mathtools}[2004/06/05]
%    \end{macrocode}
%
% ^^X SUBSECTION: Paired Delimiters
% \subsection{Declaring Paired Delimiters for Internal Use}
% \label{sec:impl-paired-delim}
%
% \begin{macro}{
%   \@@_inparent:w,
%   \@@_inbrack:w,
%   \@@_inbrace:w,
%   \@@_in_vert:w,
%   \@@_in_Vert:w
% }
% As we are going to use \pkg{mathtools}' \emph{paired delimiters}
% at several places throughout this package,
% we define \emph{paired delimiters} for internal use, as functions with weird
% syntax.
%    \begin{macrocode}
\DeclarePairedDelimiter{\@@_inparent:w}{\lparen}{\rparen}
\DeclarePairedDelimiter{\@@_inbrack:w}{\lbrack}{\rbrack}
\DeclarePairedDelimiter{\@@_inbrace:w}{\lbrace}{\rbrace}
\DeclarePairedDelimiter{\@@_in_vert:w}{\lvert}{\rvert}
\DeclarePairedDelimiter{\@@_in_Vert:w}{\lVert}{\rVert}
%    \end{macrocode}
% \end{macro}
%
% ^^X SUBSECTION: Delimited Operators
% \subsection{Delimited Operators}
% \label{sec:impl-delim-op}
%
% We need three different functions for providing the delimited operators.
% But as we share a lot of code between those, we define an additional
% helper function beforehand.
% \begin{macro}{
%   \@@_operator:Nnn
% }
% The function \cs{@@_operator:Nnn} takes care of the operator part
% of the new delimiter.
% It allows the operator to have super- and subscripts.
% It takes three arugments.
% \begin{arguments}
%   \item The \meta{csname} of the operator to use.
%   \item A \meta{token list}, which is used as the superscript operator.
%
%         This argument may be empty
%   \item A \meta{tl}, which is used as the subscript operator.
%
%         The \meta{tl} may be empty.
% \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_operator:Nnn
{
  #1
  % add superscript if present
  \tl_if_empty:nF {#2} {^{#2}}
  % add subscript if present
  \tl_if_empty:nF {#3} { \c_math_subscript_token {#3} }
}
%    \end{macrocode}
% \end{macro}
%
% We now define three version of the delimited operators.
% \begin{macro}{
%   \conmath_delim_op_noscale:NNnnn,
%   \conmath_delim_op_autoscale:NNnnn,
% }
%   \cs{conmath_delim_op_noscale:NNnnn} is provides a delimited operator without
%   any scaling of the delimiters
%   and \cs{conmath_delim_op_autoscale:NNnnn} provides a version with
%   automatic scaling of the delimiters.
%   Both of them take five arguments:
%   \begin{arguments}
%     \item The \meta{csname} of the operator to use.
%
%           Any operator declared with \pkg{amsmath}'s \cs{operatorname}
%           and/or\linebreak[3]
%           \cs[module=amsmath,replace=false]{DeclareMathOperator}
%           is valid for this.
%
%     \item The \meta{csname} of a paired delimiter declared by
%     \pkg{mathtools}'~\autocite{mathtools}
%     \cs[module=mathtools,replace=false]{DeclarePairedDelimiter}.
%
%     \item A \meta{tl} to use as the superscript of the operator.
%
%     \item A \meta{tl} to use as the subscript of the operator.
%
%     \item A \meta{tl} to insert inside the delimiters.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_delim_op_noscale:NNnnn
{
  \@@_operator:Nnn #1 {#3} {#4}
  % #2 is the paired delimiter
  #2 {#5}
}

\cs_new_protected_nopar:Nn \conmath_delim_op_autoscale:NNnnn
{
  \@@_operator:Nnn #1 {#3} {#4}
  % #2 is the paired delimiter
  #2 * {#5}
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \conmath_delim_op_manuscale:NNnnnn,
%   \conmath_delim_op_manuscale:NNVnnn
% }
%   \cs{conmath_delim_op_manuscale:NNnnnn} provides a delimited operator with
%   manual scaling.
%   This version takes six arguments:
%   \begin{arguments}
%     \item The \meta{csname} of the operator to use.
%
%     \item The \meta{csname} of the paired delimiter
%     declared by \pkg{mathtools}'~\autocite{mathtools}\linebreak[3]
%     \cs[module=mathtools,replace=false]{DeclarePairedDelimiter}.
%
%     \item A \meta{tl} containing the scaling macro i.e.\ \cs{big}, \cs{Big},
%       \cs{Bigg},\dots
%
%     \item A \meta{tl} containing the superscript of the operator.
%
%      The \meta{tl} may be empty
%
%     \item A \meta{tl} containing the subscript of the operator
%
%       The \meta{tl} may be empty.
%
%     \item A \meta{tl} to insert inside the delimiters
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_delim_op_manuscale:NNnnnn
{
  \@@_operator:Nnn #1 {#4} {#5}
  % #2 is the paired delimiter
  #2 [ #3 ] {#6}
}
%    \end{macrocode}
% We also provide a variant for the scaling macro.
%    \begin{macrocode}
\cs_generate_variant:Nn \conmath_delim_op_manuscale:NNnnnn {NNVnnn}
%    \end{macrocode}
% \end{macro}
%
% For the creation of document level commands we also create a function,
% so that the user is also able to declare new delimited operators.
% But before we do so we create a message to inform the user if a
% \meta{csname} was already taken.
%    \begin{macrocode}
\msg_new:nnn { conmath } { delimop / already-defined-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~definition~of~delimited~operator~'#1'~\msg_line_context:.
}
%    \end{macrocode}
%
% We also create a message to inform the user about conflicting options
% given to the command.
%    \begin{macrocode}
\msg_new:nnn { conmath } { delimop / auto-manu-scale-conflict }
{
  Both~star~and~scale~cmd~given~to~'#1'.\\
  Automatic~scaling~will~be~preferred,~the~size~command~will~be~
  ignored~\msg_line_context:.
}
%    \end{macrocode}
% \begin{macro}{
%   \conmath_new_delim_op_command:NNN,
%   \conmath_new_delim_op_command:cNN,
%}
% \cs{conmath_new_delim_op_command:NNN} takes three arguments:
% \begin{arguments}
%   \item The \meta{csname} to be defined.
%
%   \item The \meta{csname} of the operator to use,
%   which should be an operator declared with
%   \cs[module=amsmath,replace=false]{DeclareMathOperator}.
%
%   \item The \meta{csname} of the delimiter to use,
%   which should have been declared with
%   \cs[module=mathtools,replace=false]{DeclarePairedDelimiter}.
% \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \conmath_new_delim_op_command:NNN
{
  \cs_if_free:NTF #1
  {
    \exp_args:NNe \NewDocumentCommand #1
    { s o E{ ^ \char_generate:nn {`_} {8} }{{}{}} m }
    {
      \tl_if_novalue:nTF {##2}
      {
        % second argument empty
        \bool_if:nTF {##1}
        {
          % star given
          \conmath_delim_op_autoscale:NNnnn #2 #3 {##3} {##4} {##5}
        }{
          % star not given
          \conmath_delim_op_noscale:NNnnn #2 #3 {##3} {##4} {##5}
        }
      }{
        % second argument present
        % star given?
        \bool_if:nTF {##1}
        {
          % Warn if both star and scaling factor are present
          \msg_warning:nnn { conmath } { delimop / auto-manu-scale-conflict }
            {#1}
          \conmath_delim_op_autoscale:NNnnn #2 #3 {##3} {##4} {##5}
        }{ % FALSE BRANCH
        \conmath_delim_op_manuscale:NNnnnn #2 #3 {##2} {##3} {##4} {##5}
        }
      }
    }
  }{ % \cs_if_free:nTF #1 FALSE BRANCH
    \msg_warning:nnn { conmath } { delimop / already-defined-skip }
      {#1}
  }
}

\cs_generate_variant:Nn \conmath_new_delim_op_command:NNN {cNN}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Document Level Commands}
% \label{sec:impl-delim-op-doc-cmds}
%
% \begin{macro}{\DeclareDelimitedOperator}
%     Finally provide the user with a command to declare an additional
%     delimited operator.
%    \begin{macrocode}
\NewDocumentCommand\DeclareDelimitedOperator { m m m }
{
  \msg_redirect_name:nnn { conmath } { delimop / already-defined-skip } { error }
  \conmath_new_delim_op_command:NNN #1 #2 #3
  \msg_redirect_name:nnn { conmath } { delimop / already-defined-skip } {}
}
%    \end{macrocode}
% \end{macro}
%
% As \pkg{amsmath}~\autocite{amsmath} pre-defines the following operators
% it is only sensible to also define delimited versions of them:\\
% \input{\jobname-ams-op-table.tex}
%
% \begin{macro}{\@@_new_delim_op_cmds:nN}
%   \cs{@@_new_delim_op_cmds:nN} creates document level macros of the form
%   \cs[no-index]{\meta{prefix}\meta{op name}}.
%   It declares fife versions \cs[no-index]{p\meta{op name}},
%   \cs[no-index]{b\meta{op name}}, \cs[no-index]{B\meta{op name}},
%   \cs[no-index]{v\meta{op name}} and \cs[no-index]{V\meta{op name}}.
%
%   The function takes two arguments:
%   \begin{arguments}
%     \item A token list which contains \meta{op name}
%
%     \item The \meta{csname} of the operator to use.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_delim_op_cmds:nN
{
  \conmath_new_delim_op_command:cNN {p #1} #2 \@@_inparent:w
  \conmath_new_delim_op_command:cNN {b #1} #2 \@@_inbrack:w
  \conmath_new_delim_op_command:cNN {B #1} #2 \@@_inbrace:w
  \conmath_new_delim_op_command:cNN {v #1} #2 \@@_in_vert:w
  \conmath_new_delim_op_command:cNN {V #1} #2 \@@_in_Vert:w
}
%    \end{macrocode}
% \end{macro}
%
%  The decision if the following macros are defined depends on a package load
%  time option.
%    \begin{macrocode}
\bool_if:NTF \l_@@_predef_operators_bool
{
%    \end{macrocode}
% We define the commands for the operators already declared by amsmath.
% \begin{macro}[documented-as=\parccos]{
%   \parccos, \barccos, \Barccos, \varccos, \Varccos,
% }
% For \cs{arccos},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {arccos} \arccos
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \parcsin, \barcsin, \Barcsin, \varcsin, \Varcsin,
% }
% \cs{arcsin},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {arcsin} \arcsin
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \parctan, \barctan, \Barctan, \varctan, \Varctan,
% }
% \cs{arctan},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {arctan} \arctan
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \Parg, \barg, \Barg, \varg, \Varg,
% }
% \cs{arg}
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {arg} \arg
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcos, \bcos, \Bcos, \vcos, \Vcos,
% }
% \cs{cos}
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {cos} \cos
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcosh, \bcosh, \Bcosh, \vcosh, \Vcosh,
% }
% \cs{cosh},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {cosh} \cosh
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcot, \bcot, \Bcot, \vcot, \Vcot,
% }
% \cs{cot},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {cot} \cot
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcoth, \bcoth, \Bcoth, \vcoth, \Vcoth,
% }
% \cs{coth},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {coth} \coth
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcsc, \bcsc, \Bcsc, \vcsc, \Vcsc,
% }
% \cs{csc},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {csc} \csc
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pdeg, \bdeg, \Bdeg, \vdeg, \Vdeg,
% }
% \cs{deg},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {deg} \deg
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pdet, \bdet, \Bdet, \vdet, \Vdet,
% }
% \cs{det},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {det} \det
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pdim, \bdim, \Bdim, \vdim, \Vdim,
% }
% \cs{dim},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {dim} \dim
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pexp, \bexp, \Bexp, \vexp, \Vexp,
% }
% \cs{exp},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {exp} \exp
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pgcd, \bgcd, \Bgcd, \vgcd, \Vgcd,
% }
% \cs{gcd},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {gcd} \gcd
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \phom, \bhom, \Bhom, \vhom, \Vhom,
% }
% \cs{hom},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {hom} \hom
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pinf, \binf, \Binf, \vinf, \Vinf,
% }
% \cs{inf},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {inf} \inf
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pinjlim, \binjlim, \Binjlim, \vinjlim, \Vinjlim,
% }
% \cs{injlim},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {injlim} \injlim
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pker, \bker, \Bker, \vker, \Vker,
% }
% \cs{ker},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {ker} \ker
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \plg, \blg, \Blg, \vlg, \Vlg,
% }
% \cs{lg},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {lg} \lg
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \plim, \blim, \Blim, \vlim, \Vlim,
% }
% \cs{lim},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {lim} \lim
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pliminf, \bliminf, \Bliminf, \vliminf, \Vliminf,
% }
% \cs{liminf},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {liminf} \liminf
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \plimsup, \blimsup, \Blimsup, \vlimsup, \Vlimsup,
% }
% \cs{limsup},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {limsup} \limsup
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pln, \bln, \Bln, \vln, \Vln,
% }
% \cs{ln}
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {ln} \ln
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \plog, \blog, \Blog, \vlog, \Vlog,
% }
% \cs{log},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {log} \log
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pmax, \bmax, \Bmax, \vmax, \Vmax,
% }
% \cs{max},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {max} \max
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pmin, \bmin, \Bmin, \vmin, \Vmin,
% }
% \cs{min},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {min} \min
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pPr, \bPr, \BPr, \vPr, \VPr,
% }
% \cs{Pr},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {Pr} \Pr
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pprojlim, \bprojlim, \Bprojlim, \vprojlim, \Vprojlim,
% }
% \cs{projlim},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {projlim} \projlim
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \psec, \bsec, \Bsec, \vsec, \Vsec,
% }
% \cs{sec},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {sec} \sec
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \psin, \bsin, \Bsin, \vsin, \Vsin,
% }
% \cs{sin},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {sin} \sin
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \psinh, \bsinh, \Bsinh, \vsinh, \Vsinh,
% }
% \cs{sinh},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {sinh} \sinh
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \psup, \bsup, \Bsup, \vsup, \Vsup,
% }
% \cs{sup},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {sup} \sup
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \ptan, \btan, \Btan, \vtan, \Vtan,
% }
% \cs{tan},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {tan} \tan
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \ptanh, \btanh, \Btanh, \vtanh, \Vtanh
% }
% and \cs{tanh}.
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {tanh} \tanh
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \pvarinjlim, \bvarinjlim, \Bvarinjlim, \vvarinjlim, \Vvarinjlim,
%   \pvarprojlim, \bvarprojlim, \Bvarprojlim, \vvarprojlim, \Vvarprojlim,
%   \pvarliminf, \bvarliminf, \Bvarliminf, \vvarliminf, \Vvarliminf,
%   \pvarlimsup, \bvarlimsup, \Bvarlimsup, \vvarlimsup, \Vvarlimsup,
% }
%   We also provide delimited versions of \cs{varinjlim}, \cs{varprojlim},
%   \cs{varliminf} and \cs{varlimsup}.
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {varinjlim} \varinjlim
\@@_new_delim_op_cmds:nN {varprojlim} \varprojlim
\@@_new_delim_op_cmds:nN {varliminf} \varliminf
\@@_new_delim_op_cmds:nN {varlimsup} \varlimsup
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
}{
  \msg_info:nnnn {conmath} {load /disabling} {no-operators}
  {
    predefined~delimited~operator~macros
  }
} % End of the conditional
%    \end{macrocode}
%
% ^^X SUBSECTION: Vector Calculus Macros
% \subsection{Vector Calculus Macros}
% \label{sec:vector-calc}
%
% For providing macros which help with vector differentials,
% we first need some setup functions.
%
% \subsubsection{Macros Providing Symbols of Operators}
% \label{sec:op-symbols}
%
% \begin{macro}{\@@_gradient_operator_get:}
%   This function returns the gradient operator depending on the current setting
%   of the keys.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_gradient_operator_get:
{
  \tl_if_empty:NTF \l_@@_grad_op_tl
  {
    \mathop{
%    \end{macrocode}
% Otherwise we first need to check if the operator shall have an arrow over it.
% Afterwards if the nabla shall be bold.
%    \begin{macrocode}
      \bool_if:NTF \l_@@_nabla_arrow_bool
      {
        \vec{
          \bool_if:NT \l_@@_nabla_bold_bool
          {
            \boldsymbol
          }
          \l_@@_nabla_tl
        }
      }{
        \bool_if:NT \l_@@_nabla_bold_bool
        {
          \boldsymbol
        }
        \l_@@_nabla_tl
      }
    }\nolimits % \mathop
  }{
%    \end{macrocode}
% If the user provided its own implementation of the operator,
% we simply return it.
%    \begin{macrocode}
    \l_@@_grad_op_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_laplace_operator_get:}
%   Then we define a function for returning the laplace operator symbol,
%   depending on the currently set keys.
%   The function wraps the symbol for the operator inside
%   \tn{mathop} to provide the right spacing.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_laplace_operator_get:
{
  \tl_if_empty:NTF \l_@@_laplacian_tl
  {
    \mathop
    {
      \bool_if:NTF \l_@@_laplacian_delta_bool
      {
        \Delta
      }{
        \bool_if:NTF \l_@@_laplacian_arrow_bool
        {
          \vec{
            \bool_if:NT \l_@@_nabla_bold_bool {\boldsymbol}
            \l_@@_laplacian_symb_tl
          }
        }{
          \bool_if:NT \l_@@_nabla_bold_bool {\boldsymbol}
          \l_@@_laplacian_symb_tl
        }
      }
    }\nolimits
    \bool_if:NF \l_@@_laplacian_delta_bool
    {
      \c_math_superscript_token
      {
        2
      }
    }
  }{
    \l_@@_laplacian_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Macros Producing an Operator}
% \label{sec:op-macros}
%
% After we have defined the symbols it is now time to provide a function which
% produces the entire gradient operator
% \begin{macro}{
%   \conmath_gradient_operator:n,
%   \conmath_laplace_operator:n
%  }
% This function takes one arguments, the subscript to use with the operator.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_gradient_operator:n
{
  \@@_gradient_operator_get:
  \tl_if_empty:nF {#1} {\c_math_subscript_token {#1}}
}
%    \end{macrocode}
%
% Like for the gradient operator we do the same for the laplacian
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_laplace_operator:n
{
  \@@_laplace_operator_get:
  \tl_if_empty:nF {#1} {\c_math_subscript_token {#1}}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_divergence_operator:n,
%   \conmath_curl_operator:n
% }
%   Using the already defined gradient operator it is possible to define a
%   function which acts as an operator suitable for representing the divergence
%   operator and the curl operator.
%   Like the gradient operator this functions take one argument
%   \begin{arguments}
%     \item the subscript of the gradient operator.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_divergence_operator:n
{
%    \end{macrocode}
%   The braces around \cs{conmath_gradient_operator:n} are necessary to avoid
%   issues with the spacing between \tn{cdot} and the following \tn{mathopen}
%   from any braces.\footnote{%
%   See: \url{https://tex.stackexchange.com/a/223914}
%   }
%   Example:
%   \[
%   \text{With braces:}\quad \pdiv{f(x)} \text{,}
%   \qquad\text{without braces: }\quad \mathop{\nabla}\nolimits\cdot(f(x))
%   \]
%    \begin{macrocode}
  {
    \conmath_gradient_operator:n {#1}
  }
  \cdot
}

\cs_new_protected_nopar:Nn \conmath_curl_operator:n
{
  {
    \conmath_gradient_operator:n {#1}
  }
  \times
}
%    \end{macrocode}
% \end{macro}
% \subsubsection{Producing Delimited Vector Calculus Operators}
% \label{sec:delim-vec-ops}
%
% \begin{macro}{
%   \conmath_delim_nabla_op_noscale:NNnn,
%   \conmath_delim_nabla_op_autoscale:NNnn
% }
%   These functions produce a vector calculus operator with \meta{contents}
%   inside delimiters.
%   The "autoscale" variant scales the delimiters with the size of \meta{contents},
%   the "noscale" variant does no scaling at all.
% \begin{arguments}
%   \item The \meta{csname} of the operator to use.
%
%         This should have the same form as \cs{conmath_gradient_operator:n},
%         i.e.\ the function passed as \meta{csname} should accept one argument
%         to typeset as subscript.
%
%   \item The \meta{csname} of the \emph{paired delimiter} to use.
%
%         The paired delimiter has to be one declared using \pkg{mathtools}'
%         \cs[module=mathtools,replace=false]{DeclarePairedDelimiter} command.
%
%   \item A \meta{tl} with the subscript of the operator.
%
%   \item A \meta{tl} with the contents to typeset inside the delimiters
% \end{arguments}
% We begin with the "noscale" version.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_delim_nabla_op_noscale:NNnn
{
  #1 {#3} #2{#4}
}
%    \end{macrocode}
% Then we create the version with automatic scaling.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_delim_nabla_op_autoscale:NNnn
{
  #1 {#3} #2 * {#4}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_delim_nabla_op_manuscale:NNnnn
% }
%   This function produces a vector calculus operator like
%   \cs{conmath_delim_nabla_op_noscale:NNnn}
%   and \cs{conmath_delim_nabla_op_autoscale:NNnn},
%   but with manual scaling.
%   It takes five arguments:
%   \begin{arguments}
%     \item The \meta{csname} of the operator to use.
%
%     \item The \meta{csname} of the paired delimiter.
%
%     \item A \meta{token~list} containing the \meta{scale~cmd} like
%           \cs{big}, \cs{Big}, \cs{bigg}, etc.
%
%     \item A \meta{tl} with the subscript of the operator.
%
%     \item A \meta{tl} with the contents to typeset inside the delimiters.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_delim_nabla_op_manuscale:NNnnn
{
  #1 {#4} #2 [#3] {#5}
}
%    \end{macrocode}
% \begin{macro}{
%   \conmath_delim_nabla_op_manuscale:NNVnn
% }
%   We also declare a variant for passing a variable with the \meta{scale~cmd}
%   instead of a \meta{token~list}.
%    \begin{macrocode}
\cs_generate_variant:Nn \conmath_delim_nabla_op_manuscale:NNnnn {NNVnn}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% To ease the definition of those macros we define a function for defining
% the delimited  versions.
%
% Of course we also need a way to declare a user interface for this functions.
% For this purpose we first need some helpers for setting
% necessary parameters.
% \begin{macro}{\@@_parse_kv_args:nN}
%   This helper macro takes two arguments,
%   \begin{arguments}
%     \item A token list of the key-value arguments.
%     \item The \meta{csname} of a token list to put the scale value in.
%   \end{arguments}
%   The function sets the given keys but before it does so it searches for a
%   key named \verb|scale| and puts it into the second argument.
%   For this to work it is necessary that all values have \verb|=| in them.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_parse_kv_args:nN
{
%    \end{macrocode}
%   We first put the key-value arguments inside a property list.
%   Afterwards we check if the key \verb|scale| has been given.
%   If yes we pop it and assign it to the second argument.
%   Otherwise we do nothing.
%    \begin{macrocode}
  \prop_set_from_keyval:Nn \l_tmpa_prop {#1}

  \prop_pop:NnNT \l_tmpa_prop {scale} #2 {}

  \keys_set:ne {conmath} {\prop_to_keyval:N \l_tmpa_prop}
}
%    \end{macrocode}
% \end{macro}
%
% We also need a warning message for conflicting arguments,
% to inform the user that one of his options is going to be ignored.
%    \begin{macrocode}
\msg_new:nnn { conmath } { vector-calc / scale-star-conflict }
{
  Both~star~and~scaling~factor~given~to~'#1'.\\
  Automatic~scaling~will~be~preferred,~the~size~command~'#2'~will~be~
  ignored~\msg_line_context:.
}
%    \end{macrocode}
%
% \begin{macro}{
%   \@@_new_delim_nabla_doc_cmd:NNN,
%   \@@_new_delim_nabla_doc_cmd:cNN,
% }
%   This function takes three arguments:
%   \begin{arguments}
%     \item The \meta{csname} of the to be defined command
%     \item The \meta{csname} of the operator to use.
%
%           This should be a function like \cs{conmath_gradient_operator:n}.
%     \item The \meta{csname} of the delimiter function to use.
%
%     This should be a macro/command created with \pkg{mathtools}
%     \cs[module=mathtools,replace=false]{DeclarePairedDelimiter} command.
%   \end{arguments}
%   Its purpose is to create a new document level command,
%   for the delimited vector calculus operators.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_delim_nabla_doc_cmd:NNN
{
  \cs_if_free:NTF #1
  {
    \exp_args:NNe \NewDocumentCommand #1
    {
      s ={scale} o E{ \char_generate:nn {`_}{8} }{ {} } m
    }
    { % command code
      \group_begin:
      % optional arguments given?
      \tl_if_novalue:nF {##2}
      {
        \@@_parse_kv_args:nN {##2} \l_tmpa_tl
      }
      % star given?
      \bool_if:nTF {##1}
      {
        % scale factor given?
        \tl_if_empty:NF \l_tmpa_tl
        {
          \msg_warning:nnnV { conmath } { vector-calc / scale-star-conflict }
            {#1} \l_tmpa_tl
        }
        \conmath_delim_nabla_op_autoscale:NNnn #2 #3 {##3} {##4}
      }{ % \bool_if:nTF {##1} FALSE BRANCH
        % scale factor given?
        \tl_if_empty:NTF \l_tmpa_tl
        {
          \conmath_delim_nabla_op_noscale:NNnn #2 #3 {##3} {##4}
        }{ % FALSE BRANCH
          \conmath_delim_nabla_op_manuscale:NNVnn #2 #3 \l_tmpa_tl {##3} {##4}
        }
      } % \bool_if:nTF {##1}
      \group_end:
    }
  }{ % \cs_if_free:NTF #1 FALSE BRANCH
    \msg_warning:nnn { conmath } { vector-calc / already-defined-skip } {#1}
  } % \cs_if_free:NTF #1
}
%
\cs_generate_variant:Nn \@@_new_delim_nabla_doc_cmd:NNN {cNN}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_new_nabla_doc_cmds:nN}
%   This internal function creates five different document level commands at once,
%   using \cs{@@_new_delim_nabla_doc_cmd:cNN}.
%   It takes two arguments:
%   \begin{arguments}
%     \item The a \meta{suffix~tl} for constructing the command names.
%
%     The resulting commands will have the form \cs[no-index]{p\meta{suffix}},
%     \cs[no-index]{b\meta{suffix}}, \cs[no-index]{B\meta{suffix}},
%     \cs[no-index]{v\meta{suffix}} and \cs[no-index]{V\meta{suffix}}.
%
%     \item The \meta{csname} of the operator to use
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_nabla_doc_cmds:nN
{
  \@@_new_delim_nabla_doc_cmd:cNN { p #1 } #2 \@@_inparent:w
  \@@_new_delim_nabla_doc_cmd:cNN { b #1 } #2 \@@_inbrack:w
  \@@_new_delim_nabla_doc_cmd:cNN { B #1 } #2 \@@_inbrace:w
  \@@_new_delim_nabla_doc_cmd:cNN { v #1 } #2 \@@_in_vert:w
  \@@_new_delim_nabla_doc_cmd:cNN { V #1 } #2 \@@_in_Vert:w
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Document Level Commands}
% \label{sec:vec-doc-lvl-commands}
%
% The predefined macros for vector calculus are also guarded by a package
% option to be conditionally disabled by the user.
%    \begin{macrocode}
\bool_if:NTF \l_@@_predef_vector_op_bool
{
%    \end{macrocode}
% \paragraph{Standalone Operators}
% \label{par:impl-vector-calc-standalone}
% The user might want to use also a non-delimited version
% of the vector calculus operators,
% we provide them with a standalone version of those.
%
% As the definition of a new document command can fail if the \meta{csname}
% clashes with some already defined macro,
% we define an error message to use when defining document level commands.
%    \begin{macrocode}
\msg_new:nnn { conmath } { vector-calc / already-defined-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~definition~\msg_line_context:.
}
%    \end{macrocode}
%
% \begin{macro}{
%   \grad,
%   \divergence,
%   \curl,
%   \laplacian
% }
% Now we provide the user with document level commands for
% \cs[no-index]{conmath_\meta{op}_operator:n}.
%    \begin{macrocode}
\cs_if_free:NTF \grad
{
  \exp_args:NNe \NewDocumentCommand \grad { o E{ \char_generate:nn {`_}{8} }{{}} }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath} {#1}
    }
    \conmath_gradient_operator:n {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} { vector-calc / already-defined-skip } {\grad}
}

\cs_if_free:NTF \divergence
{
  \exp_args:NNe \NewDocumentCommand \divergence
  { o E{ \char_generate:nn {`_} {8} }{{}} }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath} {#1}
    }
    \conmath_divergence_operator:n {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} { vector-calc / already-defined-skip } {\divergence}
}

\cs_if_free:NTF \curl
{
  \exp_args:NNe \NewDocumentCommand \curl { o E{ \char_generate:nn {`_}{8} }{{}} }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath} {#1}
    }
    \conmath_curl_operator:n {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} {vector-calc / already-defined-skip} {\curl}
}

\cs_if_free:NTF \laplacian
{
  \exp_args:NNe \NewDocumentCommand \laplacian
  { o E{ \char_generate:nn {`_}{8} }{{}} }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath} {#1}
    }
    \conmath_laplace_operator:n {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} { vector-calc / already-defined-skip }
  {\laplacian}
}
%    \end{macrocode}
% \end{macro}
%
% \paragraph{Operators with Delimiters}
% \label{par:impl-vec-calc-op-delim}
%
% \begin{NOTE}{MI}
% Redo the document level commands using the new functions.
% \end{NOTE}
% \begin{macro}{
%   \pgrad,
%   \bgrad,
%   \Bgrad,
%   \vgrad,
%   \Vgrad,
% }
%   Now lets declare the delimited gradient operators.
%   We provide five versions using parenthesis, brackets, braces, single \tn{vert},
%   and double \tn{Vert}.
%    \begin{macrocode}
\@@_new_nabla_doc_cmds:nN {grad} \conmath_gradient_operator:n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \pdiv,
%   \bdiv,
%   \Bdiv,
%   \vdiv,
%   \Vdiv
% }
% Now we do the same for the divergence operator.
%    \begin{macrocode}
\@@_new_nabla_doc_cmds:nN {div} \conmath_divergence_operator:n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \pcurl,
%   \bcurl,
%   \Bcurl,
%   \vcurl,
%   \Vcurl
% }
% Now to the curl macros.
%    \begin{macrocode}
\@@_new_nabla_doc_cmds:nN {curl} \conmath_curl_operator:n
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \plaplacian,
%   \blaplacian,
%   \Blaplacian,
%   \vlaplacian,
%   \Vlaplacian
% }
% Next we take care of the laplacian
%    \begin{macrocode}
\@@_new_nabla_doc_cmds:nN {laplacian} \conmath_laplace_operator:n
%    \end{macrocode}
% \end{macro}
%
% If the user issued \texttt{no-vector} as a package loading option,
% write this to the log file.
%    \begin{macrocode}
}{ % IF NOT \l_@@_predef_vector_op_bool
  \msg_info:nnnn {conmath} { load /disabling } {no-vector}
  {
    predefined~vector~calculus~macros
  }
} % END \l_@@_predef_vector_op_bool
%    \end{macrocode}
%
% \subsection{Macros Producing Matrices and Vectors}
% \label{sec:impl-matr-vec}
%
% \subsubsection{Producing Row and Column Vectors}
%
% The functions in this section are used to generate row and column vectors
% utilizing \pkg{mathtools}~\autocite{mathtools} \env{matrix*} and
% \env{smallmatrix*} environments.
%
% \begin{variable}{\l_@@_vector_entries_seq}
%   For generating row or column vectors it is necessary to store the entries
%   inside a variable. \cs{l_@@_vector_entries_seq} is used for this purpose.
%    \begin{macrocode}
\seq_new:N \l_@@_vector_entries_seq
%    \end{macrocode}
% \end{variable}
%
% Then we need a function for formatting the actual entries of the vector.
% We need two version one for the row vector and one for the column vector
% version.
% \begin{macro}{
%   \@@_seq_to_column_vector:N,
%   \@@_seq_to_row_vector:N
% }
%   These functions take one argument
%   \begin{arguments}
%     \item A sequence which should be converted to the contents of the single
%     column/row matrix.
%   \end{arguments}
%   They format the input suitable to be put inside a \env{matrix*} environment.
% We begin with the column vector version.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_seq_to_column_vector:N
{
  \seq_use:Nn #1 {\\}
}
%    \end{macrocode}
% Then we get to the row vector.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_seq_to_row_vector:N
{
  \seq_use:Nn #1 {&}
}
%    \end{macrocode}
% \end{macro}
%
% In the next step we construct the single row/column matrix from the user
% provided input.
% \begin{macro}{
%   \conmath_column_vector:nn,
%   \conmath_row_vector:nn,
% }
%   The two commands \cs{conmath_column_vector:n} and \cs{conmath_row_vector:n}
%   construct the matrix, they both take two arguments.
%   \begin{arguments}
%     \item The delimiter specifier.
%
%     This should be one of the prefixes of the \env{\meta{prefix}matrix*},
%     environments.
%
%     Another possibility is to issue |small| as this parameter to get
%     an inline matrix.
%
%     \item The comma separated contents of the matrix.
%   \end{arguments}
%     \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_column_vector:nn
{
  \seq_clear:N \l_@@_vector_entries_seq
  \seq_set_from_clist:Nn \l_@@_vector_entries_seq {#2}

  \exp_args:NnNV \begin{#1 matrix*} [ \l_@@_matrix_align_tl ]
    \@@_seq_to_column_vector:N \l_@@_vector_entries_seq
  \end{#1 matrix*}
}

\cs_new_protected_nopar:Nn \conmath_row_vector:nn
{
  \seq_clear:N \l_@@_vector_entries_seq
  \seq_set_from_clist:Nn \l_@@_vector_entries_seq {#2}

  \exp_args:NnNV \begin{#1matrix*} [ \l_@@_matrix_align_tl ]
    \@@_seq_to_row_vector:N \l_@@_vector_entries_seq
  \end{#1matrix*}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_column_smallvector:nn,
%   \conmath_row_smallvector:nn
% }
%   To make the code more readable, we define functions specifically for
%   creating row and column vectors using the \env{smallmatrix*} family of
%   environments. These functions take the same arguments as the non-small
%   versions above.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_column_smallvector:nn
{
  \conmath_column_vector:nn {#1 small} {#2}
}

\cs_new_protected_nopar:Nn \conmath_row_smallvector:nn
{
  \conmath_row_vector:nn {#1 small} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% ^^X SUBSUBSECTION: Shorthands for simple matrices
% \subsubsection{Shorthands for Simple Matrices}
% \label{sec:impl-matr-shorth}
%
% The construction of several simple matrices like diagonal matrices,
% can be simplified as there is no need to use the \env{matrix} environment.
%
% \begin{variable}{
%   \l_@@_mat_diag_entries_seq,
%   \l_@@_mat_row_entries_seq,
% }
% We construct the matrices row by row, therefore we need to store the
% currently constructed row inside a variable.
% The same is true for the diagonal entries which also need to be stored
% somewhere.
% We therefore declare two sequence variables \cs{l_@@_mat_diag_entries_seq}
% and \cs{l_@@_mat_row_seq} for this purpose
%    \begin{macrocode}
\seq_clear_new:N \l_@@_mat_diag_entries_seq
\seq_clear_new:N \l_@@_mat_row_entries_seq
%    \end{macrocode}
% \end{variable}
%
% We split the construction of the matrix into multiple parts,
% utilizing internal helper functions.
% \begin{macro}{
%   \@@_constr_diagmat_row:n,
%   \@@_constr_antidiagmat_row:n
% }
%   \cs{@@_constr_diagmat_row:n} and \cs{@@_constr_antidiagmat_row:n}
%   take one integer argument:
%   \begin{arguments}
%     \item The number of the current row.
%   \end{arguments}
%   They both construct a matrix row and place it inside the input stream.
%   They take the content of the (anti-)diagonal from the variable
%   \cs{l_@@_mat_diag_entries_seq}
%   and use the variable \cs{l_@@_mat_row_entries_seq}
%   to store the current row.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_constr_diagmat_row:n
{
  \seq_clear:N \l_@@_mat_row_entries_seq
%    \end{macrocode}
%   As all diagonal matrices \(M \in A^{m \times n}\), where \(A\) is a field,
%   are quadratic i.e.\ \(A^{m \times n} \equiv A^{n \times n}\) the length of the
%   diagonal sequence equals the number of rows and columns of the matrix.
%   We exploit this fact here.
%    \begin{macrocode}
  \int_step_inline:nn {\seq_count:N \l_@@_mat_diag_entries_seq}
  {
    \int_compare:nTF { #1 == ##1 }
    {
      \seq_put_right:Nx \l_@@_mat_row_entries_seq
      {
        \seq_item:Nn \l_@@_mat_diag_entries_seq { #1 }
      }
    }{ % false branch
      \seq_put_right:NV \l_@@_mat_row_entries_seq \l_@@_matrix_fill_tl
    } % \int_compare:nTF { #1 == ##1 }
  }
  \seq_use:Nn \l_@@_mat_row_entries_seq { & } \\
}

% Anti-diagonal version
\cs_new_protected:Nn \@@_constr_antidiagmat_row:n
{
  \seq_clear:N \l_@@_mat_row_entries_seq
  \int_step_inline:nn {\seq_count:N \l_@@_mat_diag_entries_seq}
  {
    \int_compare:nTF { #1 == ##1 }
    {
      % as this is a anti diagonal matrix we put in the elements from the
      % left so that the first entry is the right most entry
      \seq_put_left:Nx \l_@@_mat_row_entries_seq
      {
        \seq_item:Nn  \l_@@_mat_diag_entries_seq { #1 }
      }
    }{ % false branch
      \seq_put_left:NV \l_@@_mat_row_entries_seq \l_@@_matrix_fill_tl
    } % \int_compare:nTF { #1 == ##1 }
  }
  \seq_use:Nn \l_@@_mat_row_entries_seq { & } \\
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_diagonal_matrix:nn,
%   \conmath_diagonal_matrix:Vn,
%   \conmath_antidiagonal_matrix:nn,
%   \conmath_antidiagonal_matrix:Vn,
%   \conmath_diagonal_smallmatrix:nn,
%   \conmath_diagonal_smallmatrix:Vn,
%   \conmath_antidiagonal_smallmatrix:nn,
%   \conmath_antidiagonal_smallmatrix:Vn,
% }
%   The \cs[no-index]{conmath_\meta{a or d}_matrix:nn} and
%   \cs[no-index]{conmath_\meta{a or d}_smallmatrix:nn} family of functions
%   produce a matrix based on \pkg{mathtools}~\autocite{mathtools}
%   \env{matrix*} environment.
%   The functions take two arguments.
%   \begin{arguments}
%     \item The delimiter specifier.
%
%     This should be one of the prefixes of the \env{\meta{prefix}matrix*}
%     environments.
%
%     \item The comma separated contents of the (anti-)diagonal.
%   \end{arguments}
%   These functions also use the values of the variables
%   \cs{l_@@_matrix_fill_tl} and \cs{l_@@_matrix_align_tl}.
%   And modifies the variable \cs{l_@@_mat_diag_entries_seq}.
%    \begin{macrocode}
\cs_new_protected:Nn \conmath_diagonal_matrix:nn
{
  \seq_set_from_clist:Nn \l_@@_mat_diag_entries_seq { #2 }
  \exp_args:NnNV \begin{#1 matrix*} [ \l_@@_matrix_align_tl ]
    \int_step_function:nN { \seq_count:N \l_@@_mat_diag_entries_seq }
      \@@_constr_diagmat_row:n
  \end{#1 matrix*}
}

% Anti-diagonal matrix
\cs_new_protected:Nn \conmath_antidiagonal_matrix:nn
{
  \seq_set_from_clist:Nn \l_@@_mat_diag_entries_seq { #2 }
  \exp_args:NnNV \begin{ #1 matrix* } [ \l_@@_matrix_align_tl ]
    \int_step_function:nN { \seq_count:N \l_@@_mat_diag_entries_seq }
      \@@_constr_antidiagmat_row:n
  \end{ #1 matrix* }
}

% Small versions
\cs_new_protected:Nn \conmath_diagonal_smallmatrix:nn
{
  \conmath_diagonal_matrix:nn {#1 small} {#2}
}

\cs_new_protected:Nn \conmath_antidiagonal_smallmatrix:nn
{
  \conmath_antidiagonal_matrix:nn {#1 small} {#2}
}
%    \end{macrocode}
% For convenience we also define some variants of the above functions.
%    \begin{macrocode}
\cs_generate_variant:Nn \conmath_diagonal_matrix:nn { V n }
\cs_generate_variant:Nn \conmath_antidiagonal_matrix:nn { V n }
\cs_generate_variant:Nn \conmath_diagonal_smallmatrix:nn { V n }
\cs_generate_variant:Nn \conmath_antidiagonal_smallmatrix:nn { V n }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Document Level Commands}
% \label{sec:mat-doc-lvl-cmds}
%
% Now we define document level commands for the previously defined
% functions.
%
% But before we do so we define a message to be issued in case the targeted
% \meta{csname} is already defined elsewhere.
%    \begin{macrocode}
\msg_new:nnnn { conmath } { matrix / already-defined-doc-cmd-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~definition~\msg_line_context:.
}
{
  The~control~sequence~'#1'~has~already\\
  been~defined~by~some~other~package.\\
  And~I~am~refusing~to~overwrite~the~existing~definition,\\
  therefore~I~am~skipping~the~definition~of~this~command.
}
%    \end{macrocode}
% We begin with the row and column vector functions.
% As with the other document level commands, we guard the definitions
% with a key value option, so that the user can disable them.
%    \begin{macrocode}
\bool_if:nTF \l_@@_predef_crvector_bool
{
%    \end{macrocode}
% \begin{macro}{
%   \cvector,
%   \rvector,
%   \smallcvector,
%   \smallrvector
% }
% First we define the document level command for the bare column vector
%    \begin{macrocode}
\cs_if_free:NTF \cvector
{
  \NewDocumentCommand \cvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_column_vector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % issue a warning message if the csname is already taken.
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \cvector
  }
} % \cs_if_free:NTF \cvector
%    \end{macrocode}
% and the row vector.
%    \begin{macrocode}
\cs_if_free:NTF \rvector
{
  \NewDocumentCommand \rvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_row_vector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % warn if csname is already taken
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip}
  {
    \rvector
  }
} % \cs_if_free:NTF \rvector
%    \end{macrocode}
% Then we define the smaller inline versions of those commands.
%    \begin{macrocode}
\cs_if_free:NTF \smallcvector
{
  \NewDocumentCommand \smallcvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath / matrix} {#1}
    }
    \conmath_column_smallvector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % Issue a warning message if the csname is already taken
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smallcvector
  }
} % \cs_if_free:NTF \smallcvector

\cs_if_free:NTF \smallrvector
{
  \NewDocumentCommand \smallrvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_row_smallvector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % warn if csname is taken
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smallrvector
  }
}
%    \end{macrocode}
% \end{macro}
%
% Next we define several shorthands to for the commonly used delimiters,
% to avoid code duplication, we first create some helper functions which
% define those functions.
% \begin{macro}{
%   \@@_new_vector_shorth_doc_cmd:NNn
% }
%   The function \cs{@@_new_vector_shorth_doc_cmd} creates a new vector shorthand,
%   command. It takes three arguments:
%   \begin{arguments}
%     \item The \meta{csname} to be defined.
%     \item The \meta{function} to use for this shorthand.
%
%     This should be one of the
%     \cs[no-index]{conmath_\meta{type}_\meta{size}vector:nn}
%     like commands.
%
%     \item The \meta{delimiter} to use.
%
%      Usually one of |p|, |b|, |B|, |v|, |V|.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_vector_shorth_doc_cmd:NNn
{
  \cs_if_free:NTF #1
  {
    \NewDocumentCommand #1 { o m }
    {
      \group_begin:
      % set the delimiter key pre-set for this function
      \keys_set:nn {conmath / matrix } {delimiter = #3}
      \tl_if_novalue:nF {##1}
      {
        \keys_set:nn {conmath / matrix } {##1}
      }
      #2 {\l_@@_matrix_delim_tl} {##2}
      \group_end:
    }
  }{
    % warn if csname is taken
    \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
    {
      #1
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \pcvector,
%   \bcvector,
%   \Bcvector,
%   \vcvector,
%   \Vcvector,
%   \prvector,
%   \brvector,
%   \Brvector,
%   \vrvector,
%   \Vrvector,
% }
%   Now we define shorthands for all of the matrix types so that the user
%   does not have to specify |delimiter=|\meta{delim} every time.
%   We begin with the column vector.
%    \begin{macrocode}
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \pcvector \conmath_column_vector:nn {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \bcvector \conmath_column_vector:nn {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Bcvector \conmath_column_vector:nn {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vcvector \conmath_column_vector:nn {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vcvector \conmath_column_vector:nn {V}
%    \end{macrocode}
%   Now to the row vectors.
%    \begin{macrocode}
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \prvector \conmath_row_vector:nn {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \brvector \conmath_row_vector:nn {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Brvector \conmath_row_vector:nn {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vrvector \conmath_row_vector:nn {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vrvector \conmath_row_vector:nn {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \psmallcvector,
%   \bsmallcvector,
%   \Bsmallcvector,
%   \vsmallcvector,
%   \Vsmallcvector,
%   \psmallrvector,
%   \bsmallrvector,
%   \Bsmallrvector,
%   \vsmallrvector,
%   \Vsmallrvector
% }
%   We also define shorthands for the \cs{shortcvector} and \cs{shortrvector}
%   versions.
%    \begin{macrocode}
% column vectors
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \psmallcvector \conmath_column_smallvector:nn
  {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \bsmallcvector \conmath_column_smallvector:nn
  {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Bsmallcvector \conmath_column_smallvector:nn
  {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vsmallcvector \conmath_column_smallvector:nn
  {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vsmallcvector \conmath_column_smallvector:nn
  {V}
%
% row vectors
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \psmallrvector \conmath_row_smallvector:nn {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \bsmallrvector \conmath_row_smallvector:nn {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Bsmallrvector \conmath_row_smallvector:nn {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vsmallrvector \conmath_row_smallvector:nn {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vsmallrvector \conmath_row_smallvector:nn {V}


}{ % \bool_if:nTF \l_@@_predef_crvector_bool FALSE PATH
  \msg_info:nnnn {conmath} {load / disabling} {no-crvector}
  {
    commands~producing~row~and~column~vectors
  }
} % \bool_if:nTF \l_@@_predef_crvector_bool
%    \end{macrocode}
% \end{macro}
%
% Now to the (anti-)diagonal matrix shorthands,
% these are also guarded by a key value option.
%    \begin{macrocode}
\bool_if:nTF \l_@@_predef_matrix_bool
{
%    \end{macrocode}
% \begin{macro}{
%   \diagmat,
%   \antidiagmat,
%   \smalldiagmat,
%   \smallantidiagmat,
% }
%    \begin{macrocode}
\cs_if_free:NTF \diagmat
{
  \NewDocumentCommand \diagmat { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_diagonal_matrix:Vn \l_@@_matrix_delim_tl {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} {matrix / already-defined-doc-cmd-skip}
  {
    \diagmat
  }
} % \cs_if_free:nTF \diagmat

\cs_if_free:NTF \antidiagmat
{
  \NewDocumentCommand \antidiagmat { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_antidiagonal_matrix:Vn \l_@@_matrix_delim_tl {#2}
    \group_end:
  }
}{
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \antidiagmat
  }
} % \cs_if_free:nTF \antidiagmat

\cs_if_free:NTF \smalldiagmat
{
  \NewDocumentCommand \smalldiagmat { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_diagonal_smallmatrix:Vn \l_@@_matrix_delim_tl {#2}
    \group_end:
  }
}{
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smalldiagmat
  }
}

\cs_if_free:NTF \smallantidiagmat
{
  \NewDocumentCommand \smallantidiagmat { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_antidiagonal_smallmatrix:Vn \l_@@_matrix_delim_tl {#2}
    \group_end:
  }
}{
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smallantidiagmat
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \@@_new_matrix_shorth_doc_cmd:NNn
% }
%   To provide several shorthands for delimited matrices,
%   we use a helper function to avoid code duplication.
%   \cs{@@_new_matrix_shorth_doc_cmd:NNn} takes three arguments:
%   \begin{arguments}
%     \item The \meta{csname} to define
%     \item The \meta{csname} of the matrix function to use,
%           which should have the signature |Vn|.
%      \item The \enquote{predefined} delimiter of this version
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_matrix_shorth_doc_cmd:NNn
{
  \cs_if_free:NTF #1
  {
    \NewDocumentCommand #1 { o m }
    {
      \group_begin:
      \tl_if_empty:nF {#3}
      {
        \keys_set:nn { conmath / matrix }
        {
          delimiter = #3
        }
      } % \tl_if_empty:nF {#3}
      \tl_if_novalue:nF {##1}
      {
        \keys_set:nn { conmath / matrix } {##1}
      }
      #2 \l_@@_matrix_delim_tl {##2}
      \group_end:
    }
  }{
    \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
    {
      #1
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% We now define the shorthand commands with predefined delimiters.
% \begin{macro}{
%   \pdiagmat,
%   \bdiagmat,
%   \Bdiagmat,
%   \vdiagmat,
%   \Vdiagmat,
% }
%   We begin with the regular diagonal matrix
%    \begin{macrocode}
\@@_new_matrix_shorth_doc_cmd:NNn \pdiagmat \conmath_diagonal_matrix:Vn {p}
\@@_new_matrix_shorth_doc_cmd:NNn \bdiagmat \conmath_diagonal_matrix:Vn {b}
\@@_new_matrix_shorth_doc_cmd:NNn \Bdiagmat \conmath_diagonal_matrix:Vn {B}
\@@_new_matrix_shorth_doc_cmd:NNn \vdiagmat \conmath_diagonal_matrix:Vn {v}
\@@_new_matrix_shorth_doc_cmd:NNn \Vdiagmat \conmath_diagonal_matrix:Vn {V}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \pantidiagmat,
%   \bantidiagmat,
%   \Bantidiagmat,
%   \vantidiagmat,
%   \Vantidiagmat,
%  }
%   Now for the anti-diagonal matrix commands.
%    \begin{macrocode}
\@@_new_matrix_shorth_doc_cmd:NNn \pantidiagmat
  \conmath_antidiagonal_matrix:Vn {p}
\@@_new_matrix_shorth_doc_cmd:NNn \bantidiagmat
  \conmath_antidiagonal_matrix:Vn {b}
\@@_new_matrix_shorth_doc_cmd:NNn \Bantidiagmat
  \conmath_antidiagonal_matrix:Vn {B}
\@@_new_matrix_shorth_doc_cmd:NNn \vantidiagmat
  \conmath_antidiagonal_matrix:Vn {v}
\@@_new_matrix_shorth_doc_cmd:NNn \Vantidiagmat
  \conmath_antidiagonal_matrix:Vn {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \psmalldiagmat,
%   \bsmalldiagmat,
%   \Bsmalldiagmat,
%   \vsmalldiagmat,
%   \Vsmalldiagmat,
% }
%   We continue with the inline math versions based on the \env{smallmatrix*}
%   environment.
%    \begin{macrocode}
\@@_new_matrix_shorth_doc_cmd:NNn \psmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {p}
\@@_new_matrix_shorth_doc_cmd:NNn \bsmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {b}
\@@_new_matrix_shorth_doc_cmd:NNn \Bsmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {B}
\@@_new_matrix_shorth_doc_cmd:NNn \vsmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {v}
\@@_new_matrix_shorth_doc_cmd:NNn \Vsmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {V}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \psmallantidiagmat,
%   \bsmallantidiagmat,
%   \Bsmallantidiagmat,
%   \vsmallantidiagmat,
%   \Vsmallantidiagmat,
% }
% We provide also anti-diagonal versions of the small matrices.
%    \begin{macrocode}
\@@_new_matrix_shorth_doc_cmd:NNn \psmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {p}
\@@_new_matrix_shorth_doc_cmd:NNn \bsmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {b}
\@@_new_matrix_shorth_doc_cmd:NNn \Bsmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {B}
\@@_new_matrix_shorth_doc_cmd:NNn \vsmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {v}
\@@_new_matrix_shorth_doc_cmd:NNn \Vsmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {V}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
}{ % \bool_if:nTF \l_@@_predef_matrix_bool FALSE BRANCH
  \msg_info:nnnn {conmath} { load / disabling } { no-matrix }
  {
    (anti-)diagonal~matrix~commands
  }
} % \bool_if:nTF \l_@@_predef_matrix_bool
%    \end{macrocode}
%
%
% \subsection{Shorthand Macros for Absolute Value and Norm}
% \label{sec:impl-abs-shorthands}
%
% We first declare another warning message to inform the user of the case that,
% the \meta{csnames} are already taken.
%    \begin{macrocode}
\msg_new:nnnn { conmath } { abs-shorth / csname-already-defined-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~declaration~of~paired~delimiter~\msg_line_context:.\\
  Use~package~option~'no-abs-shorthands'~to~disable~the~paired\\
  delimiter~shorthands.
}{
  The~control~sequence~'#1'~has~already~been\\
  defined~by~something~else.\\
  I~am~refusing~to~overwrite~its~existing~definition~and~instead~avoid\\
  declaring~a~paired~delimiter.\\
}
%    \end{macrocode}
%
%
% As with the other parts these macros may be conditionally disabled.
%    \begin{macrocode}
\bool_if:NTF \l_@@_predef_abs_bool
{
%    \end{macrocode}
% \begin{macro}{\abs,\norm}
% These macros provide shorthands for \(\abs{\meta{content}}\)
% and \(\norm{\meta{content}}\).
%    \begin{macrocode}
\cs_if_free:NTF \abs
{
  \DeclarePairedDelimiter \abs {\lvert} {\rvert}
}{
  % warn if the csname is taken
  \msg_warning:nnn { conmath } { abs-shorth / csname-already-defined-skip }
    {\abs}
} % \cs_if_free:NTF \abs

\cs_if_free:NTF \norm
{
  \DeclarePairedDelimiter \norm {\lVert} {\rVert}
}{
  % warn if csname is already taken
  \msg_warning:nnn { conmath } { abs-shorth / csname-already-defined-skip }
    {\norm}
} % \cs_if_free:NTF
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
}{
  \msg_info:nnnn {conmath} {load / disabling} {no-abs-shorthands}
  {
    '\abs'~and~'\norm'~macros
  }
} % End of the conditional
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{implementation}
%
% \section*{Copyright and License}
% \addcontentsline{toc}{section}{Copyright and License}
% \label{sec:license}
%
% The following copyright notice applies to the \pkg{conmath} package:
%
% \begin{quote}
%   Copyright \textcopyright{} 2024 Marcel Ilg
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%      \url{https://www.latex-project.org/lppl.txt}
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status \enquote{maintained}.
%
% The Current Maintainer of this work is Marcel Ilg.
%
% This work consists of the files listed in \file{MANIFEST.md}.
% \end{quote}
%
% \noindent The file \file{MANIFEST.md} has to be distributed together with the
% package.
%
%
% \printbibliography[heading=bibintoc]
% \PrintChanges
% \PrintIndex

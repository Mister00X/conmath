% \iffalse meta-comment
%
% Copyright (C) 2024 Marcel Ilg
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%
%      https://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status ‘maintained’.
%
% The Current Maintainer of this work is Marcel Ilg.
%
% This work consists of the files listed in MANIFEST.md.
% \fi
%
% \iffalse
%
%<*driver>
% Generated by ctanbib
\begin{filecontents}[overwrite]{\jobname.bib}
@preamble{ "\providecommand\ctanbibpkgname[1]{\textsl{#1}}" }
@manual{amsmath,
  title = {The \ctanbibpkgname{amsmath} package},
  subtitle = {AMS mathematical facilities for LaTeX},
  author = {{The LaTeX Project Team}},
  url = {https://ctan.org/pkg/amsmath},
  urldate = {2024-06-08},
  date = {2023-05-13},
  version = {2.17o},
}

@preamble{ "\providecommand\ctanbibpkgname[1]{\textsl{#1}}" }
@manual{bm,
  title = {The \ctanbibpkgname{bm} package},
  subtitle = {Access bold symbols in maths mode},
  author = {Carlisle, David and Mittelbach, Frank and {The LaTeX Project Team}},
  url = {https://ctan.org/pkg/bm},
  urldate = {2024-06-08},
  date = {2023-12-19},
  version = {1.2f},
}

@preamble{ "\providecommand\ctanbibpkgname[1]{\textsl{#1}}" }
@manual{mathtools,
  title = {The \ctanbibpkgname{mathtools} package},
  subtitle = {Mathematical tools to use with amsmath},
  author = {Høgholm, Morten and Madsen, Lars and Robertson, Will and Wright, Joseph and {The LaTeX Project Team}},
  url = {https://ctan.org/pkg/mathtools},
  urldate = {2024-06-08},
  date = {2024-03-11},
  version = {1.30},
}
\end{filecontents}
\begin{filecontents*}[overwrite]{\jobname-ams-op-table.tex}
\begin{tabular}{rlrlrlrl}
  \cs{arccos} &\(\arccos\)  &\cs{deg}    &\( \deg \)  &\cs{lg}      &\( \lg \)      &\cs{projlim} &\( \projlim \)\\
  \cs{arcsin} &\(\arcsin\)  &\cs{det}    &\( \det \)  &\cs{lim}     &\( \lim \)     &\cs{sec}     &\( \sec \)\\
  \cs{arctan} &\(\arctan\)  &\cs{dim}    &\( \dim \)  &\cs{liminf}  &\( \liminf \)  &\cs{sin}     &\( \sin \)\\
  \cs{arg}    &\(\arg\)     &\cs{exp}    &\( \exp \)  &\cs{limsup}  &\( \limsup \)  &\cs{sinh}    &\( \sinh \)\\
  \cs{cos}    &\(\cos\)     &\cs{gcd}    &\( \gcd \)  &\cs{ln}      &\( \ln \)      &\cs{sup}     &\( \sup \)\\
  \cs{cosh}   &\(\cosh\)    &\cs{hom}    &\( \hom \)  &\cs{log}     &\( \log \)     &\cs{tan}     &\( \tan \)\\
  \cs{cot}    &\(\cot\)     &\cs{inf}    &\( \inf \)  &\cs{max}     &\( \max \)     &\cs{tanh}    &\( \tanh \)\\
  \cs{coth}   &\(\coth\)    &\cs{injlim} &\(\injlim\) &\cs{min}     &\( \min \)     &                       &\\
  \cs{csc}    &\(\csc\)     &\cs{ker}    &\(\ker\)    &\cs{Pr}      &\( \Pr \)      &                       &\\
\end{tabular}
\begin{center}
  \begin{tabular}{rlrl}
    \cs{varinjlim}  &\(\varinjlim\)   &\cs{varliminf} &\(\varliminf\)\\
    \cs{varprojlim} &\(\varprojlim\)  &\cs{varlimsup} &\(\varlimsup\)\\
  \end{tabular}
\end{center}
\end{filecontents*}

\documentclass[show-notes]{l3doc}
\usepackage[american]{babel}

\usepackage[style=alphabetic]{biblatex}
\addbibresource{\jobname.bib}

\usepackage{csquotes}

\usepackage[bm]{conmath}
\conmathsetup{arrownabla}

% renew the ctanbibpkgname command
\NewDocumentCommand\ctanbibpkgname{m}{\pkg{#1}}

\begin{document}
  \DocInput{conmath.dtx}
\end{document}
%</driver>
% \fi
%
% ^^X Get the package version name etc.
% \GetFileInfo{conmath.sty}
%
% \changes{v0.0.1}{2024-01-09}{Initial version}
%
% \title{The \textsf{conmath} package\thanks{This document coresponds to
%   \textsf{conmath}~\fileversion, dated \filedate.}}
% \author{Marcel Ilg\thanks{\texttt{mister01x (at) web (dot) de}}}
%
% \maketitle
% \begin{abstract}
% \end{abstract}
% \tableofcontents
% \begin{documentation}
% \section{Introduction}
% \label{sec:intro}
%
% \end{documentation}
% \begin{implementation}
% \section{Implementation}
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Set the internal prefix for this package so that \pkg{DocStrip} knows what to
% do.
%    \begin{macrocode}
%<@@=conmath>
%    \end{macrocode}
%
% \subsection{Initial Setup}
%
% First set the required version of \LaTeX{},
% we need at least
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2022-06-01]
%    \end{macrocode}
% for key-value option handling, \pkg{xparse}-like document commands
% and hooks.
%
% Then identify this package as \pkg{conmath}.
%    \begin{macrocode}
\ProvidesExplPackage{conmath}
  {2024-01-09}{0.1.0}{Convenience Math Macros}
%    \end{macrocode}
%
% ^^X Debugging switch
% \iffalse
% \debug_on:n {}
% \fi
% \subsection{Key-value interfaces}
% \label{sec:key-val}
% To make use of key-value interfaces we need to define a few keys.
%
% \subsubsection{Package load time options}
% \label{sec:load-time-options}
%
% To allow for the conditional definition of macros at load time
% we define a few keys.
%
% But before doing so we define a few messages to write the package options to
% the log file.
% One message to issue if the \texttt{bm} option has been given:
%    \begin{macrocode}
\msg_new:nnn { conmath } {load / bm}
{
  Option~'bm'~given.\\
  Loading~the~bm~package~\msg_line_context:.
}
%    \end{macrocode}
% And a more generic message to issue for the other options,
% which all disable certain parts of the library.
%    \begin{macrocode}
\msg_new:nnn {conmath} { load / disabling }
{
  Option~'#1'~given.\\
  Disabling~#2~\msg_line_context:.
}
%    \end{macrocode}
% \begin{optionenv}{
%   bm,
%   no-vector,
%   no-operators,
%   no-abs-shorthands,
%   no-matrix,
%   no-crvector,
%   nopredef,
% }
% Now we define package load time keys:
%    \begin{macrocode}
\keys_define:nn { conmath / load }
{
%    \end{macrocode}
% We provide an option to conditionally load the \pkg{bm}-package~\autocite{bm}
% to provide better looking bold symbols.
%    \begin{macrocode}
  bm .code:n = {
    \msg_info:nn {conmath} {load / bm}
    \RequirePackage{bm}
  },
  bm .value_forbidden:n = true,
  bm. usage:n = load,
%    \end{macrocode}
% \begin{variable}{
%   \l_@@_predef_vector_op_bool,
%   \l_@@_predef_operators_bool,
%   \l_@@_predef_crvector_bool,
%   \l_@@_predef_matrix_bool,
%   \l_@@_predef_abs_bool,
% }
% Then we define options for en-/disabling predefined macros of this package
% to avoid name clashes.
%    \begin{macrocode}
  no-vector .bool_set_inverse:N = \l_@@_predef_vector_op_bool,
  no-vector .default:n = true,
  no-vector .initial:n = false,
  no-vector .usage:n = load,
  no-operators .bool_set_inverse:N = \l_@@_predef_operators_bool,
  no-operators .default:n = true,
  no-operators .initial:n = false,
  no-operators .usage:n = load,
  no-abs-shorthands .bool_set_inverse:N = \l_@@_predef_abs_bool,
  no-abs-shorthands .default:n = true,
  no-abs-shorthands .initial:n = false,
  no-abs-shorthands .usage:n = load,
  no-matrix .bool_set_inverse:N = \l_@@_predef_matrix_bool,
  no-matrix .initial:n = false,
  no-matrix .default:n = true,
  no-matrix .usage:n =load,
  no-crvector .bool_set_inverse:N = \l_@@_predef_crvector_bool,
  no-crvector .default:n = true,
  no-crvector .initial:n = false,
  no-crvector .usage:n = load,
%    \end{macrocode}
% The variables \cs{l_@@_predef_vector_op_bool}, \cs{l_@@_predef_operators_bool}
% \cs{l_@@_predef_abs_bool}, \cs{l_@@_predef_matrix_bool}
% and \cs{l_@@_predef_crvector_bool}
% control if the predefined macros
% for vector calculus, delimited operators, the matrix shorthands,
% the row and column vectors,
% and the shorthands for absolute value
% and norm shall be defined.
% \end{variable}
%    \begin{macrocode}
  nopredef .multichoice:,
  nopredef / operators .meta:nn = { conmath / load }
  {
    no-operators = true
  },
  nopredef / vector .meta:nn = { conmath / load }
  {
    no-vector = true
  },
  nopredef / abs .meta:nn = { conmath / load }
  {
    no-abs-shorthands = true,
  },
  noperdef / matrix .meta:nn = { conmath / load }
  {
    no-matrix = true,
  },
  nopredef / crvector .meta:nn = {conmath / load}
  {
    no-crvector = true,
  },
  nopredef / all .meta:nn = { conmath / load }
  {
    no-operators = true,
    no-vector = true,
    no-abs-shorthands = true
  },
  nopredef .usage:n = load,
%    \end{macrocode}
% Unknown package options get passed to \pkg{mathtools}.
%    \begin{macrocode}
  unknown .code:n = {\PassOptionsToPackage{\CurrentOption}{mathtools}},
  unknown .usage:n = load,
}
%    \end{macrocode}
% \end{optionenv}
%
%
% \subsubsection{Keys controlling appearance}
% \label{sec:keys-appearance}
%
% \begin{optionenv}{
%   nabla,
%   arrownabla,
%   boldnabla,
%   grad-op,
%   laplacian-symb,
%   delta-laplace,
%   arrowlaplace,
%   laplacian
% }
% First define keys for the vector calculus macros.
%    \begin{macrocode}
\keys_define:nn { conmath }
{
%    \end{macrocode}
% First we define keys for use with the gradient and gradient based operators.
% \begin{variable}{
%   \l_@@_nabla_tl,
%   \l_@@_nabla_arrow_bool,
%   \l_@@_nabla_arrow_bold_bool,
%   \l_@@_grad_op_tl,
% }
%    \begin{macrocode}
  % Symbol to use for the nabla
   nabla .tl_set:N = \l_@@_nabla_tl,
   nabla .initial:n = {\nabla},
   nabla .value_required:n = true,
   % shall the nabla have an arrow over it
   arrownabla .bool_set:N = \l_@@_nabla_arrow_bool,
   arrownabla .default:n = {true},
   arrownabla .initial:n = {false},
   % shall the nabla be bold
   boldnabla .bool_set:N = \l_@@_nabla_bold_bool,
   boldnabla .default:n = {true},
   boldnabla .initial:n = {false},
%    \end{macrocode}
% The symbol to use as \enquote{nabla} is stored in \cs{l_@@_nabla_tl}.
% The variables \cs{l_@@_nabla_arrow_bool} and \cs{l_@@_nabla_bold_bool}
% determine if the nabla-symbol shall have an arrow over itself and/or be bold
% respectively.
%
% We also provide an override for the gradient operator
%    \begin{macrocode}
   % Symbol to use for the gradient operator
   grad-op .tl_set:N = \l_@@_grad_op_tl,
   grad-op .value_required:n = true,
%    \end{macrocode}
% The variable \cs{l_@@_grad_op_tl} contains a user provided token list to
% overwrite the built-in gradient operator of the package.
% \end{variable}
%
% \begin{variable}{
%   \l_@@_laplacian_symb_tl,
%   \l_@@_laplacian_delta_bool,
%   \l_@@_laplacian_arrow_bool,
%   \l_@@_laplacian_tl,
% }
% Then we define keys for the laplacian.
%    \begin{macrocode}
   % Symbol to use for the laplacian
   laplacian-symb .tl_set:N = \l_@@_laplacian_symb_tl,
   laplacian-symb .initial:n = {\l_@@_nabla_tl},
   % shall the Laplace operator be a delta
   delta-laplace .bool_set:N = \l_@@_laplacian_delta_bool,
   delta-laplace .initial:n = {false},
   % shall the laplace operator have an arrow over itself
   arrowlaplace .bool_set:N = \l_@@_laplacian_arrow_bool,
   arrowlaplace .default:n = {true},
   arrowlaplace .initial:n = {false},
   % overwrite the laplace operator
   laplacian .tl_set:N = \l_@@_laplacian_tl,
   laplacian .value_required:n = true,
}
%    \end{macrocode}
% The token list variable \cs{l_@@_laplacian_symb_tl} stores the tokens to be
% used for the Laplace operator.
% The boolean variable \cs{l_@@_laplacian_delta_bool}
% determines if a delta should be used instead
% of \(\laplacian\) for the laplacian symbol.
% If the boolean variable \cs{l_@@_laplacian_arrow_bool} a small arrow will be
% placed over the Laplace operator symbol.
% If the user wants to overwrite the symbol used for the Laplacian,
% the user provided list of tokens is stored in the variable
% \cs{l_@@_laplacian_tl}.
% \end{variable}
% \end{optionenv}
%
% \begin{optionenv}{
%   delimiter,
%   fill,
%   align
% }
% Then we define some keys for the matrix based environments:
%    \begin{macrocode}
\keys_define:nn { conmath / matrix }
{
%    \end{macrocode}
% \begin{variable}{
% \l_@@_matrix_delim_tl,
% \l_@@_matrix_fill_tl,
% \l_@@_matrix_align_tl,
% }
% Every one of the following keys stores its value inside a token list variable.
%    \begin{macrocode}
  delimiter .tl_set:N = \l_@@_matrix_delim_tl,
  delimiter .initial:n = {},
  fill .tl_set:N = \l_@@_matrix_fill_tl,
  fill .initial:n = {},
  align .tl_set:N = \l_@@_matrix_align_tl,
  align .initial:n = {c},
  align .value_required:n = true,
}
%    \end{macrocode}
% The keys \verb|delimiter| and \verb|fill| set the variables
% \cs{l_@@_matrix_delim_tl} and \cs{l_@@_matrix_fill_tl} respectively.
% \cs{l_@@_matrix_delim_tl} determines the delimiter in use to surround
% matrices and \cs{l_@@_matrix_fill_tl} determines the fill values of the
% \cs{diag}, \cs{smalldiag}, \cs[no-index]{Xdiag} and \cs[no-index]{Xsmalldiag}
% commands, which are used for non-diagonal matrix entries.
% The variable \cs{l_@@_matrix_align_tl} contains the alignment specifier
% for use with the \env{matrix*} environment.
% \end{variable}
% \end{optionenv}
%
% \subsubsection{Functions for Setting Options}
% \label{sec:option-setters}
%
%
% Now we define a function for setting the options within the document
% \begin{macro}{\conmath_setup:n}
%    \begin{macrocode}
\cs_new_protected:Nn \conmath_setup:n
{
  \keys_set:nn {conmath} {#1}
}
%    \end{macrocode}
% \end{macro}
%
% Additionally we provide the user with a version of this command.
% \begin{macro}{\conmathsetup}
%    \begin{macrocode}
\DeclareDocumentCommand \conmathsetup {m}
{
  \conmath_setup:n {#1}
}
%    \end{macrocode}
% \end{macro}
% We also need a function for setting the package load time options.
% This function should set all given values for all key families
% and pass unknown options to mathtools.
% \begin{macro}{\@@_load_time_setup:}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_load_time_setup:
{
  \ProcessKeyOptions[ conmath / load ]
}
%    \end{macrocode}
% \end{macro}
%
% ^^X SUBSECTION: Package Initialization
% \subsection{Package Initialization}
% \label{sec:init}
%
% We now \enquote{initialize} the package by processing the package options,
% all unknown options are passed to \pkg{mathtools}~\autocite{mathtools},
% which is loaded afterwards.
% Because certain \pkg{mathtools}-features are needed by this package,
% we need to require a version of at least 2004/06/05.
% As explained in section~\ref{sec:load-time-options} this may also load \pkg{bm}
% if the \verb|bm| package option has been given.
%    \begin{macrocode}
\@@_load_time_setup:

\RequirePackage{mathtools}[2004/06/05]
%    \end{macrocode}
%
% ^^X SUBSECTION: Paired Delimiters
% \subsection{Declaring Paired Delimiters for Internal Use}
% \label{sec:impl-paired-delim}
%
% \begin{macro}{
%   \@@_inparent:w,
%   \@@_inbrack:w,
%   \@@_inbrace:w,
%   \@@_in_vert:w,
%   \@@_in_Vert:w
% }
% As we are going to use \pkg{mathtools}' \emph{paired delimiters}
% at several places throughout this package,
% we define \emph{paired delimiters} for internal use, as functions with weird
% syntax.
%    \begin{macrocode}
\DeclarePairedDelimiter{\@@_inparent:w}{\lparen}{\rparen}
\DeclarePairedDelimiter{\@@_inbrack:w}{\lbrack}{\rbrack}
\DeclarePairedDelimiter{\@@_inbrace:w}{\lbrace}{\rbrace}
\DeclarePairedDelimiter{\@@_in_vert:w}{\lvert}{\rvert}
\DeclarePairedDelimiter{\@@_in_Vert:w}{\lVert}{\rVert}
%    \end{macrocode}
% \end{macro}
%
% ^^X SUBSECTION: Delimited Operators
% \subsection{Delimited Operators}
% \label{sec:impl-delim-op}
%
% We need three different functions for providing the delimited operators.
% But as we share a lot of code between those, we define an additional
% helper function beforehand.
% \begin{macro}{
%   \@@_operator:Nnn
% }
% The function \cs{@@_operator:Nnn} takes care of the operator part
% of the new delimiter.
% It allows the operator to have super- and subscripts.
% It takes three arugments.
% \begin{arguments}
%   \item The \meta{csname} of the operator to use.
%   \item A \meta{token list}, which is used as the superscript operator.
%
%         This argument may be empty
%   \item A \meta{tl}, which is used as the subscript operator.
%
%         The \meta{tl} may be empty.
% \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_operator:Nnn
{
  #1
  % add superscript if present
  \tl_if_empty:nF {#2} {^{#2}}
  % add subscript if present
  \tl_if_empty:nF {#3} { \c_math_subscript_token {#3} }
}
%    \end{macrocode}
% \end{macro}
%
% We now define three version of the delimited operators.
% \begin{macro}{
%   \conmath_delim_op_noscale:NNnnn,
%   \conmath_delim_op_autoscale:NNnnn,
% }
%   \cs{conmat_delim_op_noscale:NNnnn} is provides a delimited operator without
%   any scaling of the delimiters
%   and \cs{conmath_delim_op_autoscale:NNnnn} provides a version with
%   automatic scaling of the delimiters.
%   Both of them take five arguments:
%   \begin{arguments}
%     \item The \meta{csname} of the operator to use.
%
%           Any operator declared with \pkg{amsmath}'s \cs{operatorname}
%           and/or\linebreak[3] \cs{DeclareMathOperator} is valid for this.
%
%     \item The \meta{csname} of a paired delimiter declared by
%           \pkg{mathtools}'~\autocite{mathtools} \cs{DeclarePairedDelimiter}.
%
%     \item A \meta{tl} to use as the superscript of the operator.
%
%     \item A \meta{tl} to use as the subscript of the operator.
%
%     \item A \meta{tl} to insert inside the delimiters.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_delim_op_noscale:NNnnn
{
  \@@_operator:Nnn #1 {#3} {#4}
  % #2 is the paired delimiter
  #2 {#5}
}

\cs_new_protected_nopar:Nn \conmath_delim_op_autoscale:NNnnn
{
  \@@_operator:Nnn #1 {#3} {#4}
  % #2 is the paired delimiter
  #2 * {#5}
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \conmath_delim_op_manuscale:NNnnnn,
%   \conmath_delim_op_manuscale:NNVnnn
% }
%   \cs{conmath_delim_op_manuscale:NNnnnn} provides a delimited operator with
%   manual scaling.
%   This version takes six arguments:
%   \begin{arguments}
%     \item The \meta{csname} of the operator to use.
%
%     \item The \meta{csname} of the paired delimiter
%     declared by \pkg{mathtools}'~\autocite{mathtools}\linebreak[3]
%     \cs{DeclarePairedDelimiter}.
%
%     \item A \meta{tl} containing the scaling macro i.e.\ \cs{big}, \cs{Big},
%       \cs{Bigg},\dots
%
%     \item A \meta{tl} containing the superscript of the operator.
%
%      The \meta{tl} may be empty
%
%     \item A \meta{tl} containing the subscript of the operator
%
%       The \meta{tl} may be empty.
%
%     \item A \meta{tl} to insert inside the delimiters
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_delim_op_manuscale:NNnnnn
{
  \@@_operator:Nnn #1 {#4} {#5}
  % #2 is the paired delimiter
  #2 [ #3 ] {#6}
}
%    \end{macrocode}
% We also provide a variant for the scaling macro.
%    \begin{macrocode}
\cs_generate_variant:Nn \conmath_delim_op_manuscale:NNnnnn {NNVnnn}
%    \end{macrocode}
% \end{macro}
%
% For the creation of document level commands we also create a function,
% so that the user is also able to declare new delimited operators.
% But before we do so we create a message to inform the user if a
% \meta{csname} was already taken.
%    \begin{macrocode}
\msg_new:nnn { conmath } { delimop / already-defined-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~definition~of~delimited~operator~'#1'~\msg_line_context:.
}
%    \end{macrocode}
%
% We also create a message to inform the user about conflicting options
% given to the command.
%    \begin{macrocode}
\msg_new:nnn { conmath } { delimop / auto-manu-scale-conflict }
{
  Both~star~and~scale~cmd~given~to~'#1'.\\
  Automatic~scaling~will~be~preferred,~the~size~command~will~be~
  ignored~\msg_line_context:.
}
%    \end{macrocode}
% \begin{macro}{
%   \conmath_new_delim_op_command:NNN,
%   \conmath_new_delim_op_command:cNN,
%}
% \cs{conmath_new_delim_op_command:NNN} takes three arguments:
% \begin{arguments}
%   \item The \meta{csname} to be defined.
%   \item The \meta{csname} of the operator to use,
%     which should be an operator declared with \cs{DeclareMathOperator}.
%   \item The \meta{csname} of the delimiter to use,
%         which should have been declared with \cs{DeclarePairedDelimiter}.
% \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \conmath_new_delim_op_command:NNN
{
  \cs_if_free:NTF #1
  {
    \exp_args:NNe \NewDocumentCommand #1
    { s o E{ ^ \char_generate:nn {`_} {8} }{{}{}} m }
    {
      \tl_if_novalue:nTF {##2}
      {
        % second argument empty
        \bool_if:nTF {##1}
        {
          % star given
          \conmath_delim_op_autoscale:NNnnn #2 #3 {##3} {##4} {##5}
        }{
          % star not given
          \conmath_delim_op_noscale:NNnnn #2 #3 {##3} {##4} {##5}
        }
      }{
        % second argument present
        % star given?
        \bool_if:nTF {##1}
        {
          % Warn if both star and scaling factor are present
          \msg_warning:nnn { conmath } { delimop / auto-manu-scale-conflict }
            {#1}
          \conmath_delim_op_autoscale:NNnnn #2 #3 {##3} {##4} {##5}
        }{ % FALSE BRANCH
        \conmath_delim_op_manuscale:NNnnnn #2 #3 {##2} {##3} {##4} {##5}
        }
      }
    }
  }{ % \cs_if_free:nTF #1 FALSE BRANCH
    \msg_warning:nnn { conmath } { delimop / already-defined-skip }
      {#1}
  }
}

\cs_generate_variant:Nn \conmath_new_delim_op_command:NNN {cNN}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Document Level Commands}
% \label{sec:impl-delim-op-doc-cmds}
%
% As \pkg{amsmath}~\autocite{amsmath} pre-defines the following operators
% it is only sensible to also define delimited versions of them:\\
% \input{\jobname-ams-op-table.tex}
%
% \begin{macro}{\@@_new_delim_op_cmds:nN}
%   \cs{@@_new_delim_op_cmds:nN} creates document level macros of the form
%   \cs[no-index]{\meta{prefix}\meta{op name}}.
%   It declares fife versions \cs[no-index]{p\meta{op name}},
%   \cs[no-index]{b\meta{op name}}, \cs[no-index]{B\meta{op name}},
%   \cs[no-index]{v\meta{op name}} and \cs[no-index]{V\meta{op name}}.
%
%   The function takes two arguments:
%   \begin{arguments}
%     \item A token list which contains \meta{op name}
%
%     \item The \meta{csname} of the operator to use.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_delim_op_cmds:nN
{
  \conmath_new_delim_op_command:cNN {p #1} #2 \@@_inparent:w
  \conmath_new_delim_op_command:cNN {b #1} #2 \@@_inbrack:w
  \conmath_new_delim_op_command:cNN {B #1} #2 \@@_inbrace:w
  \conmath_new_delim_op_command:cNN {v #1} #2 \@@_in_vert:w
  \conmath_new_delim_op_command:cNN {V #1} #2 \@@_in_Vert:w
}
%    \end{macrocode}
% \end{macro}
%
%  The decision if the following macros are defined depends on a package load
%  time option.
%    \begin{macrocode}
\bool_if:NTF \l_@@_predef_operators_bool
{
%    \end{macrocode}
% We define the commands for the operators already declared by amsmath.
% \begin{macro}[documented-as=\parccos]{
%   \parccos, \barccos, \Barccos, \varccos, \Varccos,
% }
% For \cs{arccos},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {arccos} \arccos
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \parcsin, \barcsin, \Barcsin, \varcsin, \Varcsin,
% }
% \cs{arcsin},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {arcsin} \arcsin
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \parctan, \barctan, \Barctan, \varctan, \Varctan,
% }
% \cs{arctan},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {arctan} \arctan
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \Parg, \barg, \Barg, \varg, \Varg,
% }
% \cs{arg}
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {arg} \arg
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcos, \bcos, \Bcos, \vcos, \Vcos,
% }
% \cs{cos}
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {cos} \cos
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcosh, \bcosh, \Bcosh, \vcosh, \Vcosh,
% }
% \cs{cosh},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {cosh} \cosh
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcot, \bcot, \Bcot, \vcot, \Vcot,
% }
% \cs{cot},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {cot} \cot
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcoth, \bcoth, \Bcoth, \vcoth, \Vcoth,
% }
% \cs{coth},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {coth} \coth
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pcsc, \bcsc, \Bcsc, \vcsc, \Vcsc,
% }
% \cs{csc},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {csc} \csc
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pdeg, \bdeg, \Bdeg, \vdeg, \Vdeg,
% }
% \cs{deg},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {deg} \deg
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pdet, \bdet, \Bdet, \vdet, \Vdet,
% }
% \cs{det},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {det} \det
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pdim, \bdim, \Bdim, \vdim, \Vdim,
% }
% \cs{dim},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {dim} \dim
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pexp, \bexp, \Bexp, \vexp, \Vexp,
% }
% \cs{exp},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {exp} \exp
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pgcd, \bgcd, \Bgcd, \vgcd, \Vgcd,
% }
% \cs{gcd},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {gcd} \gcd
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \phom, \bhom, \Bhom, \vhom, \Vhom,
% }
% \cs{hom},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {hom} \hom
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pinf, \binf, \Binf, \vinf, \Vinf,
% }
% \cs{inf},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {inf} \inf
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pinjlim, \binjlim, \Binjlim, \vinjlim, \Vinjlim,
% }
% \cs{injlim},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {injlim} \injlim
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pker, \bker, \Bker, \vker, \Vker,
% }
% \cs{ker},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {ker} \ker
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \plg, \blg, \Blg, \vlg, \Vlg,
% }
% \cs{lg},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {lg} \lg
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \plim, \blim, \Blim, \vlim, \Vlim,
% }
% \cs{lim},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {lim} \lim
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pliminf, \bliminf, \Bliminf, \vliminf, \Vliminf,
% }
% \cs{liminf},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {liminf} \liminf
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \plimsup, \blimsup, \Blimsup, \vlimsup, \Vlimsup,
% }
% \cs{limsup},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {limsup} \limsup
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pln, \bln, \Bln, \vln, \Vln,
% }
% \cs{ln}
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {ln} \ln
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \plog, \blog, \Blog, \vlog, \Vlog,
% }
% \cs{log},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {log} \log
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pmax, \bmax, \Bmax, \vmax, \Vmax,
% }
% \cs{max},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {max} \max
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pmin, \bmin, \Bmin, \vmin, \Vmin,
% }
% \cs{min},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {min} \min
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pPr, \bPr, \BPr, \vPr, \VPr,
% }
% \cs{Pr},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {Pr} \Pr
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \pprojlim, \bprojlim, \Bprojlim, \vprojlim, \Vprojlim,
% }
% \cs{projlim},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {projlim} \projlim
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \psec, \bsec, \Bsec, \vsec, \Vsec,
% }
% \cs{sec},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {sec} \sec
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \psin, \bsin, \Bsin, \vsin, \Vsin,
% }
% \cs{sin},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {sin} \sin
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \psinh, \bsinh, \Bsinh, \vsinh, \Vsinh,
% }
% \cs{sinh},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {sinh} \sinh
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \psup, \bsup, \Bsup, \vsup, \Vsup,
% }
% \cs{sup},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {sup} \sup
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \ptan, \btan, \Btan, \vtan, \Vtan,
% }
% \cs{tan},
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {tan} \tan
%    \end{macrocode}
% \end{macro}
% \begin{macro}[documented-as=\parccos]{
%   \ptanh, \btanh, \Btanh, \vtanh, \Vtanh
% }
% and \cs{tanh}.
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {tanh} \tanh
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \pvarinjlim, \bvarinjlim, \Bvarinjlim, \vvarinjlim, \Vvarinjlim,
%   \pvarprojlim, \bvarprojlim, \Bvarprojlim, \vvarprojlim, \Vvarprojlim,
%   \pvarliminf, \bvarliminf, \Bvarliminf, \vvarliminf, \Vvarliminf,
%   \pvarlimsup, \bvarlimsup, \Bvarlimsup, \vvarlimsup, \Vvarlimsup,
% }
%   We also provide delimited versions of \cs{varinjlim}, \cs{varprojlim},
%   \cs{varliminf} and \cs{varlimsup}.
%    \begin{macrocode}
\@@_new_delim_op_cmds:nN {varinjlim} \varinjlim
\@@_new_delim_op_cmds:nN {varprojlim} \varprojlim
\@@_new_delim_op_cmds:nN {varliminf} \varliminf
\@@_new_delim_op_cmds:nN {varlimsup} \varlimsup
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
}{
  \msg_info:nnnn {conmath} {load /disabling} {no-operators}
  {
    predefined~delimited~operator~macros
  }
} % End of the conditional
%    \end{macrocode}
%
% ^^X SUBSECTION: Vector Calculus Macros
% \subsection{Vector Calculus Macros}
% \label{sec:vector-calc}
%
% For providing macros which help with vector differentials,
% we first need some setup functions.
%
% \subsubsection{Macros Providing Symbols of Operators}
% \label{sec:op-symbols}
%
% \begin{macro}{\@@_gradient_operator_get:}
%   This function returns the gradient operator depending on the current setting
%   of the keys.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_gradient_operator_get:
{
  \tl_if_empty:NTF \l_@@_grad_op_tl
  {
    \mathop{
%    \end{macrocode}
% Otherwise we first need to check if the operator shall have an arrow over it.
% Afterwards if the nabla shall be bold.
%    \begin{macrocode}
      \bool_if:NTF \l_@@_nabla_arrow_bool
      {
        \vec{
          \bool_if:NT \l_@@_nabla_bold_bool
          {
            \boldsymbol
          }
          \l_@@_nabla_tl
        }
      }{
        \bool_if:NT \l_@@_nabla_bold_bool
        {
          \boldsymbol
        }
        \l_@@_nabla_tl
      }
    }\nolimits % \mathop
  }{
%    \end{macrocode}
% If the user provided its own implementation of the operator,
% we simply return it.
%    \begin{macrocode}
    \l_@@_grad_op_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_laplace_operator_get:}
%   Then we define a function for returning the laplace operator symbol,
%   depending on the currently set keys.
%   The function wraps the symbol for the operator inside
%   \tn{mathop} to provide the right spacing.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_laplace_operator_get:
{
  \tl_if_empty:NTF \l_@@_laplacian_tl
  {
    \mathop
    {
      \bool_if:NTF \l_@@_laplacian_delta_bool
      {
        \Delta
      }{
        \bool_if:NTF \l_@@_laplacian_arrow_bool
        {
          \vec{
            \bool_if:NT \l_@@_nabla_bold_bool {\boldsymbol}
            \l_@@_laplacian_symb_tl
          }
        }{
          \bool_if:NT \l_@@_nabla_bold_bool {\boldsymbol}
          \l_@@_laplacian_symb_tl
        }
      }
    }\nolimits
    \bool_if:NF \l_@@_laplacian_delta_bool
    {
      \c_math_superscript_token
      {
        2
      }
    }
  }{
    \l_@@_laplacian_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Macros Producing an Operator}
% \label{sec:op-macros}
%
% After we have defined the symbols it is now time to provide a function which
% produces the entire gradient operator
% \begin{macro}{
%   \conmath_gradient_operator:n,
%   \conmath_laplace_operator:n
%  }
% This function takes one arguments, the subscript to use with the operator.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_gradient_operator:n
{
  \@@_gradient_operator_get:
  \tl_if_empty:nF {#1} {\c_math_subscript_token {#1}}
}
%    \end{macrocode}
%
% Like for the gradient operator we do the same for the laplacian
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_laplace_operator:n
{
  \@@_laplace_operator_get:
  \tl_if_empty:nF {#1} {\c_math_subscript_token {#1}}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_divergence_operator:n,
%   \conmath_curl_operator:n
% }
%   Using the already defined gradient operator it is possible to define a
%   function which acts as an operator suitable for representing the divergence
%   operator and the curl operator.
%   Like the gradient operator this functions take one argument
%   \begin{arguments}
%     \item the subscript of the gradient operator.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_divergence_operator:n
{
%    \end{macrocode}
%   The braces around \cs{conmath_gradient_operator:n} are necessary to avoid
%   issues with the spacing between \tn{cdot} and the following \tn{mathopen}
%   from any braces.\footnote{%
%   See: \url{https://tex.stackexchange.com/a/223914}
%   }
%   Example:
%   \[
%   \text{With braces:}\quad \pdiv{f(x)} \text{,}
%   \qquad\text{without braces: }\quad \mathop{\nabla}\nolimits\cdot(f(x))
%   \]
%    \begin{macrocode}
  {
    \conmath_gradient_operator:n {#1}
  }
  \cdot
}

\cs_new_protected_nopar:Nn \conmath_curl_operator:n
{
  {
    \conmath_gradient_operator:n {#1}
  }
  \times
}
%    \end{macrocode}
% \end{macro}
% \subsubsection{Producing Delimited Vector Calculus Operators}
% \label{sec:delim-vec-ops}
%
% To avoid duplicating a lot of code we declare a functions which
% declare the delimited versions of those operators.
% \begin{macro}{
%   \@@_new_delim_nabla_op_noscale:NNN,
%   \@@_new_delim_nabla_op_noscale:cNN,
%   \@@_new_delim_nabla_op_autoscale:NNN,
%   \@@_new_delim_nabla_op_autoscale:cNN,
%   \@@_new_delim_nabla_op_manuscale:NNN,
%   \@@_new_delim_nabla_op_manuscale:cNN,
% }
% Each of those functions takes three arguments:
% \begin{arguments}
%   \item The \meta{cs-name} of to be defined
%   \item The \meta{operator} to use.
%
%   This should be one of the \cs{conmath_gradient_operator:n}-like functions.
%   \item The paired delimiter to use, for example \cs{@@_inparent:w}.
% \end{arguments}
%
% We begin with the non scaled version,
% This version takes two arguments
% \begin{arguments}
%   \item \dots{}the subscript
%   \item and the content to be inside the delimiters.
% \end{arguments}
% Its signature should therefore be of the form
% \cs[no-index]{\meta{prefix}_\meta{operator name}_noscale:nn}.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_delim_nabla_op_noscale:NNN
{
  \cs_new_protected_nopar:Nn #1
  {
    #2 {##1} #3{##2}
  }
}
%    \end{macrocode}
%
% Next we provide the function with automatic scaling.
% Like above this version also takes three arguments.
% The signature of the function produced by this function should have the form
% \cs[no-index]{\meta{prefix}_\meta{operator name}_autoscale:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_delim_nabla_op_autoscale:NNN
{
  \cs_new_protected_nopar:Nn #1
  {
    #2 {##1} #3*{##2}
  }
}
%    \end{macrocode}
%
% Finally we define the version with manual scaling.
% The function declared by this function should have the signature
% \cs[no-index]{\meta{prefix}_\meta{operator name}_manuscale:nnn}
% and takes the following arguments:
% \begin{arguments}
%   \item The scaling macro which is passed to \cls{mathtools}' paired delimiter.
%   \item The subscript of the operator
%   \item The contents inside the delimiters.
% \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_delim_nabla_op_manuscale:NNN
{
  \cs_new_protected_nopar:Nn #1
  {
    #2 {##2} #3 [##1] {##3}
  }
}
%    \end{macrocode}
%
% For good measure we also declare some variants of these functions
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_new_delim_nabla_op_noscale:NNN {cNN}
\cs_generate_variant:Nn \@@_new_delim_nabla_op_autoscale:NNN {cNN}
\cs_generate_variant:Nn \@@_new_delim_nabla_op_manuscale:NNN {cNN}
%    \end{macrocode}
% \end{macro}
%
% To ease the definition of those macros we define a function for defining
% the delimited  versions.
% \begin{macro}{\@@_new_delim_nabla_ops:nN}
%   This macro takes a three arguments
%   \begin{arguments}
%     \item The name part of the to be produced \meta{csname}
%     \item The operator to use
%     \item The delimiter function to use.
%   \end{arguments}
%  It declares functions with a signature with the form
%  \cs[no-index]{conmath_\#1_noscale:nn},
%  \cs[no-index]{conmath_\#1_autoscale:nn}
%  and \cs[no-index]{conmath_\#1_manuscale:nnn}.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_delim_nabla_ops:nNN
{
  \@@_new_delim_nabla_op_noscale:cNN {conmath_#1_noscale:nn} #2 #3
  \@@_new_delim_nabla_op_autoscale:cNN {conmath_#1_autoscale:nn} #2 #3
  \@@_new_delim_nabla_op_manuscale:cNN {conmath_#1_manuscale:nnn} #2 #3
}
%    \end{macrocode}
% \end{macro}
%
%
% Of course we also need a way to declare a user interface for this functions.
% For this purpose we first need some helpers for setting
% necessary parameters.
% \begin{macro}{\@@_parse_kv_args:nN}
%   This helper macro takes two arguments,
%   \begin{arguments}
%     \item A token list of the key-value arguments.
%     \item The \meta{csname} of a token list to put the scale value in.
%   \end{arguments}
%   The function sets the given keys but before it does so it searches for a
%   key named \verb|scale| and puts it into the second argument.
%   For this to work it is necessary that all values have \verb|=| in them.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_parse_kv_args:nN
{
%    \end{macrocode}
%   We first put the key-value arguments inside a property list.
%   Afterwards we check if the key \verb|scale| has been given.
%   If yes we pop it and assign it to the second argument.
%   Otherwise we do nothing.
%    \begin{macrocode}
  \prop_set_from_keyval:Nn \l_tmpa_prop {#1}

  \prop_pop:NnNT \l_tmpa_prop {scale} #2 {}

  \keys_set:ne {conmath} {\prop_to_keyval:N \l_tmpa_prop}
}
%    \end{macrocode}
% \end{macro}
% We also need a warning message for conflicting arguments % TODO
%
% \begin{macro}{\@@_new_nabla_doc_command:NNNN}
%   This function takes four arguments
%   \begin{arguments}
%     \item The name of the to be defined command
%     \item The function to use without scaling
%     \item The function to use for automatic scaling
%     \item The function to use for manual scaling
%   \end{arguments}
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_nabla_doc_command:NNNN
{
  \cs_if_free:NTF #1
  {
    \exp_args:NNe \NewDocumentCommand #1
    {s  ={scale} o E{\char_generate:nn{`_}{8}}{{}} m}
    {
      \group_begin:
      % optional arguments given?
      \tl_if_novalue:nF{##2}
      {
        \@@_parse_kv_args:nN {##2} \l_tmpa_tl
      }
      % scale parameter given?
      \tl_if_empty:NTF \l_tmpa_tl
      {
        % star given?
        \bool_if:nTF {##1}
        {
          % automatic scaling
          #3 {##3} {##4}
        }{
          % no scaling
          #2 {##3} {##4}
        }
      }{
        % manual scaling
        \exp_args:No #4 \l_tmpa_tl {##3} {##4}
      }
      \group_end:
    }
  }{
    \msg_warning:nnn {conmath} { vector-calc / already-defined-skip } #1
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Document Level Commands}
% \label{sec:vec-doc-lvl-commands}
%
% The predefined macros for vector calculus are also guarded by a package
% option to be conditionally disabled by the user.
%    \begin{macrocode}
\bool_if:NTF \l_@@_predef_vector_op_bool
{
%    \end{macrocode}
% The user might want to use also a non-delimited version
% of the vector calculus operators,
% we provide them with a standalone version of those.
%
% As the definition of a new document command can fail if the \meta{csname}
% clashes with some already defined macro,
% we define an error message to use when defining document level commands.
%    \begin{macrocode}
\msg_new:nnn { conmath } { vector-calc / already-defined-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~definition~\msg_line_context:.
}
%    \end{macrocode}
%
% \begin{macro}{
%   \grad,
%   \divergence,
%   \curl,
%   \laplacian
% }
% Now we provide the user with document level commands for
% \cs[no-index]{conmath_\meta{op}_operator:n}.
%    \begin{macrocode}
\cs_if_free:NTF \grad
{
  \exp_args:NNe \NewDocumentCommand \grad { o E{ \char_generate:nn {`_}{8} }{{}} }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath} {#1}
    }
    \conmath_gradient_operator:n {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} { vector-calc / already-defined-skip } {\grad}
}

\cs_if_free:NTF \divergence
{
  \exp_args:NNe \NewDocumentCommand \divergence
  { o E{ \char_generate:nn {`_} {8} }{{}} }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath} {#1}
    }
    \conmath_divergence_operator:n {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} { vector-calc / already-defined-skip } {\divergence}
}

\cs_if_free:NTF \curl
{
  \exp_args:NNe \NewDocumentCommand \curl { o E{ \char_generate:nn {`_}{8} }{{}} }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath} {#1}
    }
    \conmath_curl_operator:n {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} {vector-calc / already-defined-skip} {\curl}
}

\cs_if_free:NTF \laplacian
{
  \exp_args:NNe \NewDocumentCommand \laplacian
  { o E{ \char_generate:nn {`_}{8} }{{}} }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath} {#1}
    }
    \conmath_laplace_operator:n {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} { vector-calc / already-defined-skip }
  {\laplacian}
}
%    \end{macrocode}
% \end{macro}
%
% Now lets declare the delimited gradient operators:
% \begin{macro}{
%   \conmath_pgrad_noscale:nn,
%   \conmath_pgrad_autoscale:nn,
%   \conmath_pgrad_manuscale:nnn,
%   \pgrad
% }
% First we provide the version delimited by parenthesis,
%    \begin{macrocode}
\@@_new_delim_nabla_ops:nNN {pgrad} \conmath_gradient_operator:n \@@_inparent:w

\@@_new_nabla_doc_command:NNNN \pgrad
  \conmath_pgrad_noscale:nn
  \conmath_pgrad_autoscale:nn
  \conmath_pgrad_manuscale:nnn
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \conmath_bgrad_noscale:nn,
%   \conmath_bgrad_autoscale:nn,
%   \conmath_bgrad_manuscale:nnn,
%   \bgrad
% }
% followed by the bracketed version,
%    \begin{macrocode}
\@@_new_delim_nabla_ops:nNN {bgrad} \conmath_gradient_operator:n \@@_inbrack:w

\@@_new_nabla_doc_command:NNNN \bgrad
  \conmath_bgrad_noscale:nn
  \conmath_bgrad_autoscale:nn
  \conmath_brgad_manuscale:nnn
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \conmath_Bgrad_noscale:nn,
%   \conmath_Bgrad_autoscale:nn,
%   \conmath_Bgrad_manuscale:nnn,
%   \Bgrad
% }
% the version delimited by braces,
%    \begin{macrocode}
\@@_new_delim_nabla_ops:nNN {Bgrad} \conmath_gradient_operator:n \@@_inbrace:w

\@@_new_nabla_doc_command:NNNN \Bgrad
  \conmath_Bgrad_noscale:nn
  \conmath_Bgrad_autoscale:nn
  \conmath_Bgrad_manuscale:nnn
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \conmath_vgrad_noscale:nn,
%   \conmath_vgrad_autoscale:nn,
%   \conmath_vgrad_manuscale:nnn,
%   \vgrad
% }
% the version delimited by the pipe-symbol aka.\ \texttt{\enquote{\(\vert\)}},
%    \begin{macrocode}
\@@_new_delim_nabla_ops:nNN {vgrad} \conmath_gradient_operator:n \@@_in_vert:w

\@@_new_nabla_doc_command:NNNN \vgrad
  \conmath_vgrad_noscale:nn
  \conmath_vgrad_autoscale:nn
  \conmath_vgrad_manuscale:nnn
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \conmath_Vgrad_noscale:nn,
%   \conmath_Vgrad_autoscale:nn,
%   \conmath_Vgrad_manuscale:nnn,
%   \Vgrad
% }
% and finally the version delimited by \texttt{\enquote{\(\Vert\)}}.
%    \begin{macrocode}
\@@_new_delim_nabla_ops:nNN {Vgrad} \conmath_gradient_operator:n \@@_in_Vert:w

\@@_new_nabla_doc_command:NNNN \Vgrad
  \conmath_Vgrad_noscale:nn
  \conmath_Vgrad_autoscale:nn
  \conmath_Vgrad_manuscale:nnn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_pdiv_noscale:nn,
%   \conmath_pdiv_autoscale:nn,
%   \conmath_pdiv_manuscale:nnn,
%   \pdiv,
%   \conmath_bdiv_noscale:nn,
%   \conmath_bdiv_autoscale:nn,
%   \conmath_bdiv_manuscale:nnn,
%   \bdiv,
%   \conmath_Bdiv_noscale:nn,
%   \conmath_Bdiv_autoscale:nn,
%   \conmath_Bdiv_manuscale:nnn,
%   \Bdiv,
%   \conmath_vdiv_noscale:nn,
%   \conmath_vdiv_autoscale:nn,
%   \conmath_vdiv_manuscale:nnn,
%   \vdiv,
%   \conmath_Vdiv_noscale:nn,
%   \conmath_Vdiv_autoscale:nn,
%   \conmath_Vdiv_manuscale:nnn,
%   \Vdiv
% }
% Now we do the same for the divergence operator.
%    \begin{macrocode}
% parenthesis
\@@_new_delim_nabla_ops:nNN {pdiv} \conmath_divergence_operator:n
  \@@_inparent:w

\@@_new_nabla_doc_command:NNNN \pdiv
  \conmath_pdiv_noscale:nn
  \conmath_pdiv_autoscale:nn
  \conmath_pdiv_manuscale:nnn

% brackets
\@@_new_delim_nabla_ops:nNN {bdiv} \conmath_divergence_operator:n
  \@@_inbrack:w

\@@_new_nabla_doc_command:NNNN \bdiv
  \conmath_bdiv_noscale:nn
  \conmath_bdiv_autoscale:nn
  \conmath_bdiv_manuscale:nnn

% braces
\@@_new_delim_nabla_ops:nNN {Bdiv} \conmath_divergence_operator:n
  \@@_inbrace:w

\@@_new_nabla_doc_command:NNNN \Bdiv
  \conmath_Bdiv_noscale:nn
  \conmath_Bdiv_autoscale:nn
  \conmath_Bdiv_manuscale:nnn

% pipe symbol
\@@_new_delim_nabla_ops:nNN {vdiv} \conmath_divergence_operator:n
  \@@_in_vert:w

\@@_new_nabla_doc_command:NNNN \vdiv
  \conmath_vdiv_noscale:nn
  \conmath_vdiv_autoscale:nn
  \conmath_vdiv_manuscale:nnn

% double pipes
\@@_new_delim_nabla_ops:nNN {Vdiv} \conmath_divergence_operator:n
  \@@_in_Vert:w

\@@_new_nabla_doc_command:NNNN \Vdiv
  \conmath_Vdiv_noscale:nn
  \conmath_Vdiv_autoscale:nn
  \conmath_Vdiv_manuscale:nnn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_pcurl_noscale:nn,
%   \conmath_pcurl_autoscale:nn,
%   \conmath_pcurl_manuscale:nnn,
%   \pcurl,
%   \conmath_bcurl_noscale:nn,
%   \conmath_bcurl_autoscale:nn,
%   \conmath_bcurl_manuscale:nnn,
%   \bcurl,
%   \conmath_Bcurl_noscale:nn,
%   \conmath_Bcurl_autoscale:nn,
%   \conmath_Bcurl_manuscale:nnn,
%   \Bcurl,
%   \conmath_vcurl_noscale:nn,
%   \conmath_vcurl_autoscale:nn,
%   \conmath_vcurl_manuscale:nnn,
%   \vcurl,
%   \conmath_Vcurl_noscale:nn,
%   \conmath_Vcurl_autoscale:nn,
%   \conmath_Vcurl_manuscale:nnn,
%   \Vcurl
% }
% Now to the curl macros.
%    \begin{macrocode}
% parenthesis
\@@_new_delim_nabla_ops:nNN {pcurl} \conmath_divergence_operator:n
  \@@_inparent:w

\@@_new_nabla_doc_command:NNNN \pcurl
  \conmath_pcurl_noscale:nn
  \conmath_pcurl_autoscale:nn
  \conmath_pcurl_manuscale:nnn

% brackets
\@@_new_delim_nabla_ops:nNN {bcurl} \conmath_divergence_operator:n
  \@@_inbrack:w

\@@_new_nabla_doc_command:NNNN \bcurl
  \conmath_bcurl_noscale:nn
  \conmath_bcurl_autoscale:nn
  \conmath_bcurl_manuscale:nnn

% braces
\@@_new_delim_nabla_ops:nNN {Bcurl} \conmath_divergence_operator:n
  \@@_inbrace:w

\@@_new_nabla_doc_command:NNNN \Bcurl
  \conmath_Bcurl_noscale:nn
  \conmath_Bcurl_autoscale:nn
  \conmath_Bcurl_manuscale:nnn

% single pipes
\@@_new_delim_nabla_ops:nNN {vcurl} \conmath_divergence_operator:n
  \@@_in_vert:w

\@@_new_nabla_doc_command:NNNN \vcurl
  \conmath_vcurl_noscale:nn
  \conmath_vcurl_autoscale:nn
  \conmath_vcurl_manuscale:nnn

% double pipes
\@@_new_delim_nabla_ops:nNN {Vcurl} \conmath_divergence_operator:n
  \@@_in_Vert:w

\@@_new_nabla_doc_command:NNNN \Vcurl
  \conmath_Vcurl_noscale:nn
  \conmath_Vcurl_autoscale:nn
  \conmath_Vcurl_manuscale:nnn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_plaplacian_noscale:nn,
%   \conmath_plaplacian_autoscale:nn,
%   \conmath_plaplacian_manuscale:nnn,
%   \plaplacian,
%   \conmath_blaplacian_noscale:nn,
%   \conmath_blaplacian_autoscale:nn,
%   \conmath_blaplacian_manuscale:nnn,
%   \blaplacian,
%   \conmath_Blaplacian_noscale:nn,
%   \conmath_Blaplacian_autoscale:nn,
%   \conmath_Blaplacian_manuscale:nnn,
%   \Blaplacian,
%   \conmath_vlaplacian_noscale:nn,
%   \conmath_vlaplacian_autoscale:nn,
%   \conmath_vlaplacian_manuscale:nnn,
%   \vlaplacian,
%   \conmath_Vlaplacian_noscale:nn,
%   \conmath_Vlaplacian_autoscale:nn,
%   \conmath_Vlaplacian_manuscale:nnn,
%   \Vlaplacian
% }
% Next we take care of the laplacian
%    \begin{macrocode}
% parenthesis
\@@_new_delim_nabla_ops:nNN {plaplacian} \conmath_laplace_operator:n
  \@@_inparent:w

\@@_new_nabla_doc_command:NNNN \plaplacian
  \conmath_plaplacian_noscale:nn
  \conmath_plaplacian_autoscale:nn
  \conmath_plaplacian_manuscale:nnn

% brackets
\@@_new_delim_nabla_ops:nNN {blaplacian} \conmath_laplace_operator:n
  \@@_inbrack:w

\@@_new_nabla_doc_command:NNNN \blaplacian
  \conmath_blaplacian_noscale:nn
  \conmath_blaplacian_autoscale:nn
  \conmath_blaplacian_manuscale:nnn

% braces
\@@_new_delim_nabla_ops:nNN {Blaplacian} \conmath_laplace_operator:n
  \@@_inbrace:w

\@@_new_nabla_doc_command:NNNN \Blaplacian
  \conmath_Blaplacian_noscale:nn
  \conmath_Blaplacian_autoscale:nn
  \conmath_Blaplacian_manuscale:nnn

% single pipes
\@@_new_delim_nabla_ops:nNN {vlaplacian} \conmath_laplace_operator:n
  \@@_in_vert:w

\@@_new_nabla_doc_command:NNNN \vlaplacian
  \conmath_vlaplacian_noscale:nn
  \conmath_vlaplacian_autoscale:nn
  \conmath_vlaplacian_manuscale:nnn

% double pipes
\@@_new_delim_nabla_ops:nNN {Vlaplacian} \conmath_laplace_operator:n
  \@@_in_Vert:w

\@@_new_nabla_doc_command:NNNN \Vlaplacian
  \conmath_Vlaplacian_noscale:nn
  \conmath_Vlaplacian_autoscale:nn
  \conmath_Vlaplacian_manuscale:nnn
%    \end{macrocode}
% \end{macro}
% If the user issued \texttt{no-vector} as a package loading option,
% write this to the log file.
%    \begin{macrocode}
}{ % IF NOT \l_@@_predef_vector_op_bool
  \msg_info:nnnn {conmath} { load /disabling } {no-vector}
  {
    predefined~vector~calculus~macros
  }
} % END \l_@@_predef_vector_op_bool
%    \end{macrocode}
%
% \subsection{Macros Producing Matrices and Vectors}
% \label{sec:impl-matr-vec}
%
% \subsubsection{Producing Row and Column Vectors}
%
% The functions in this section are used to generate row and column vectors
% utilizing \pkg{mathtools}~\autocite{mathtools} \env{matrix*} and
% \env{smallmatrix*} environments.
%
% \begin{variable}{\l_@@_vector_entries_seq}
%   For generating row or column vectors it is necessary to store the entries
%   inside a variable. \cs{l_@@_vector_entries_seq} is used for this purpose.
%    \begin{macrocode}
\seq_new:N \l_@@_vector_entries_seq
%    \end{macrocode}
% \end{variable}
%
% Then we need a function for formatting the actual entries of the vector.
% We need two version one for the row vector and one for the column vector
% version.
% \begin{macro}{
%   \@@_seq_to_column_vector:N,
%   \@@_seq_to_row_vector:N
% }
%   These functions take one argument
%   \begin{arguments}
%     \item A sequence which should be converted to the contents of the single
%     column/row matrix.
%   \end{arguments}
%   They format the input suitable to be put inside a \env{matrix*} environment.
% We begin with the column vector version.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_seq_to_column_vector:N
{
  \seq_use:Nn #1 {\\}
}
%    \end{macrocode}
% Then we get to the row vector.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_seq_to_row_vector:N
{
  \seq_use:Nn #1 {&}
}
%    \end{macrocode}
% \end{macro}
%
% In the next step we construct the single row/column matrix from the user
% provided input.
% \begin{macro}{
%   \conmath_column_vector:nn,
%   \conmath_row_vector:nn,
% }
%   The two commands \cs{conmath_column_vector:n} and \cs{conmath_row_vector:n}
%   construct the matrix, they both take two arguments.
%   \begin{arguments}
%     \item The delimiter specifier.
%
%     This should be one of the prefixes of the \env{\meta{prefix}matrix*},
%     environments.
%
%     Another possibility is to issue |small| as this parameter to get
%     an inline matrix.
%
%     \item The comma separated contents of the matrix.
%   \end{arguments}
%     \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_column_vector:nn
{
  \seq_clear:N \l_@@_vector_entries_seq
  \seq_set_from_clist:Nn \l_@@_vector_entries_seq {#2}

  \begin{#1 matrix*} [\l_@@_matrix_align_tl]
    \@@_seq_to_column_vector:N \l_@@_vector_entries_seq
  \end{#1 matrix*}
}

\cs_new_protected_nopar:Nn \conmath_row_vector:nn
{
  \seq_clear:N \l_@@_vector_entries_seq
  \seq_set_from_clist:Nn \l_@@_vector_entries_seq {#2}

  \begin{#1matrix*}[\l_@@_matrix_align_tl]
    \@@_seq_to_row_vector:N \l_@@_vector_entries_seq
  \end{#1matrix*}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_column_smallvector:nn,
%   \conmath_row_smallvector:nn
% }
%   To make the code more readable, we define functions specifically for
%   creating row and column vectors using the \env{smallmatrix*} family of
%   environments. These functions take the same arguments as the non-small
%   versions above.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_column_smallvector:nn
{
  \conmath_column_vector:nn {#1 small} {#2}
}

\cs_new_protected_nopar:Nn \conmath_row_smallvector:nn
{
  \conmath_row_vector:nn {#1 small} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% ^^X SUBSUBSECTION: Shorthands for simple matrices
% \subsubsection{Shorthands for Simple Matrices}
% \label{sec:impl-matr-shorth}
%
% The construction of several simple matrices like diagonal matrices,
% can be simplified as there is no need to use the \env{matrix} environment.
%
% \begin{variable}{
%   \l_@@_mat_diag_entries_seq,
%   \l_@@_mat_row_entries_seq,
% }
% We construct the matrices row by row, therefore we need to store the
% currently constructed row inside a variable.
% The same is true for the diagonal entries which also need to be stored
% somewhere.
% We therefore declare two sequence variables \cs{l_@@_mat_diag_entries_seq}
% and \cs{l_@@_mat_row_seq} for this purpose
%    \begin{macrocode}
\seq_clear_new:N \l_@@_mat_diag_entries_seq
\seq_clear_new:N \l_@@_mat_row_entries_seq
%    \end{macrocode}
% \end{variable}
%
% We split the construction of the matrix into multiple parts,
% utilizing internal helper functions.
% \begin{macro}{
%   \@@_constr_diagmat_row:n,
%   \@@_constr_antidiagmat_row:n
% }
%   \cs{@@_constr_diagmat_row:n} and \cs{@@_constr_antidiagmat_row:n}
%   take one integer argument:
%   \begin{arguments}
%     \item The number of the current row.
%   \end{arguments}
%   They both construct a matrix row and place it inside the input stream.
%   They take the content of the (anti-)diagonal from the variable
%   \cs{l_@@_mat_diag_entries_seq}
%   and use the variable \cs{l_@@_mat_row_entries_seq}
%   to store the current row.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_constr_diagmat_row:n
{
  \seq_clear:N \l_@@_mat_row_entries_seq
%    \end{macrocode}
%   As all diagonal matrices \(M \in A^{m \times n}\), where \(A\) is a field,
%   are quadratic i.e.\ \(A^{m \times n} \equiv A^{n \times n}\) the length of the
%   diagonal sequence equals the number of rows and columns of the matrix.
%   We exploit this fact here.
%    \begin{macrocode}
  \int_step_inline:nn {\seq_count:N \l_@@_mat_diag_entries_seq}
  {
    \int_compare:nTF { #1 == ##1 }
    {
      \seq_put_right:Nx \l_@@_mat_row_entries_seq
      {
        \seq_item:Nn \l_@@_mat_diag_entries_seq { #1 }
      }
    }{ % false branch
      \seq_put_right:NV \l_@@_mat_row_entries_seq \l_@@_matrix_fill_tl
    } % \int_compare:nTF { #1 == ##1 }
  }
  \seq_use:Nn \l_@@_mat_row_entries_seq { & } \\
}

% Anti-diagonal version
\cs_new_protected:Nn \@@_constr_antidiagmat_row:n
{
  \seq_clear:N \l_@@_mat_row_entries_seq
  \int_step_inline:nn {\seq_count:N \l_@@_mat_diag_entries_seq}
  {
    \int_compare:nTF { #1 == ##1 }
    {
      % as this is a anti diagonal matrix we put in the elements from the
      % left so that the first entry is the right most entry
      \seq_put_left:Nx \l_@@_mat_row_entries_seq
      {
        \seq_item:Nn  \l_@@_mat_diag_entries_seq { #1 }
      }
    }{ % false branch
      \seq_put_left:NV \l_@@_mat_row_entries_seq \l_@@_matrix_fill_tl
    } % \int_compare:nTF { #1 == ##1 }
  }
  \seq_use:Nn \l_@@_mat_row_entries_seq { & } \\
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_diagonal_matrix:nn,
%   \conmath_diagonal_matrix:Vn,
%   \conmath_antidiagonal_matrix:nn,
%   \conmath_antidiagonal_matrix:Vn,
%   \conmath_diagonal_smallmatrix:nn,
%   \conmath_diagonal_smallmatrix:Vn,
%   \conmath_antidiagonal_smallmatrix:nn,
%   \conmath_antidiagonal_smallmatrix:Vn,
% }
%   The \cs[no-index]{conmath_\meta{a or d}_matrix:nn} and
%   \cs[no-index]{conmath_\meta{a or d}_smallmatrix:nn} family of functions
%   produce a matrix based on \pkg{mathtools}~\autocite{mathtools}
%   \env{matrix*} environment.
%   The functions take two arguments.
%   \begin{arguments}
%     \item The delimiter specifier.
%
%     This should be one of the prefixes of the \env{\meta{prefix}matrix*}
%     environments.
%
%     \item The comma separated contents of the (anti-)diagonal.
%   \end{arguments}
%   These functions also use the values of the variables
%   \cs{l_@@_matrix_fill_tl} and \cs{l_@@_matrix_align_tl}.
%   And modifies the variable \cs{l_@@_mat_diag_entries_seq}.
%    \begin{macrocode}
\cs_new_protected:Nn \conmath_diagonal_matrix:nn
{
  \seq_set_from_clist:Nn \l_@@_mat_diag_entries_seq { #2 }
  \begin{#1 matrix*} [ \l_@@_matrix_align_tl ]
    \int_step_function:nN { \seq_count:N \l_@@_mat_diag_entries_seq }
      \@@_constr_diagmat_row:n
  \end{#1 matrix*}
}

% Anti-diagonal matrix
\cs_new_protected:Nn \conmath_antidiagonal_matrix:nn
{
  \seq_set_from_clist:Nn \l_@@_mat_diag_entries_seq { #2 }
  \begin{ #1 matrix* } [ \l_@@_matrix_align_tl ]
    \int_step_function:nN { \seq_count:N \l_@@_mat_diag_entries_seq }
      \@@_constr_antidiagmat_row:n
  \end{ #1 matrix* }
}

% Small versions
\cs_new_protected:Nn \conmath_diagonal_smallmatrix:nn
{
  \conmath_diagonal_matrix:nn {#1 small} {#2}
}

\cs_new_protected:Nn \conmath_antidiagonal_smallmatrix:nn
{
  \conmath_antidiagonal_matrix:nn {#1 small} {#2}
}
%    \end{macrocode}
% For convenience we also define some variants of the above functions.
%    \begin{macrocode}
\cs_generate_variant:Nn \conmath_diagonal_matrix:nn { V n }
\cs_generate_variant:Nn \conmath_antidiagonal_matrix:nn { V n }
\cs_generate_variant:Nn \conmath_diagonal_smallmatrix:nn { V n }
\cs_generate_variant:Nn \conmath_antidiagonal_smalmatrix:nn { V n }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Document Level Commands}
% \label{sec:mat-doc-lvl-cmds}
%
% Now we define document level commands for the previously defined
% functions.
%
% But before we do so we define a message to be issued in case the targeted
% \meta{csname} is already defined elsewhere.
%    \begin{macrocode}
\msg_new:nnnn { conmath } { matrix / already-defined-doc-cmd-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~definition~\msg_line_context:.
}
{
  The~control~sequence~'#1'~has~already\\
  been~defined~by~some~other~package.\\
  And~I~am~refusing~to~overwrite~the~existing~definition,\\
  therefore~I~am~skipping~the~definition~of~this~command.
}
%    \end{macrocode}
% We begin with the row and column vector functions.
% As with the other document level commands, we guard the definitions
% with a key value option, so that the user can disable them.
%    \begin{macrocode}
\bool_if:nTF \l_@@_predef_crvector_bool
{
%    \end{macrocode}
% \begin{macro}{
%   \cvector,
%   \rvector,
%   \smallcvector,
%   \smallrvector
% }
%    \begin{macrocode}
% First we define the document level command for the bare column vector
\cs_if_free:NTF \cvector
{
  \NewDocumentCommand \cvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_column_vector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % issue a warning message if the csname is already taken.
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \cvector
  }
} % \cs_if_free:NTF \cvector
%    \end{macrocode}
% and the row vector.
%    \begin{macrocode}
\cs_if_free:NTF \rvector
{
  \NewDocumentCommand \rvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_row_vector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % warn if csname is already taken
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip}
  {
    \rvector
  }
} % \cs_if_free:NTF \rvector
%    \end{macrocode}
% Then we define the smaller inline versions of those commands.
%    \begin{macrocode}
\cs_if_free:NTF \smallcvector
{
  \NewDocumentCommand \smallcvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath / matrix} {#1}
    }
    \conmath_column_smallvector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % Issue a warning message if the csname is already taken
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smallcvector
  }
} % \cs_if_free:NTF \smallcvector

\cs_if_free:NTF \smallrvector
{
  \NewDocumentCommand \smallrvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_row_smallvector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % warn if csname is taken
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smallrvector
  }
}
%    \end{macrocode}
% \end{macro}
%
% Next we define several shorthands to for the commonly used delimiters,
% to avoid code duplication, we first create some helper functions which
% define those functions.
% \begin{macro}{
%   \@@_new_vector_shorth_doc_cmd:NNn
% }
%   The function \cs{@@_new_vector_shorth_doc_cmd} creates a new vector shorthand,
%   command. It takes three arguments:
%   \begin{arguments}
%     \item The \meta{csname} to be defined.
%     \item The \meta{function} to use for this shorthand.
%
%     This should be one of the
%     \cs[no-index]{conmath_\meta{type}_\meta{size}vector:nn}
%     like commands.
%
%     \item The \meta{delimiter} to use.
%
%      Usually one of |p|, |b|, |B|, |v|, |V|.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_vector_shorth_doc_cmd:NNn
{
  \cs_if_free:NTF #1
  {
    \NewDocumentCommand #1 { o m }
    {
      \group_begin:
      % set the delimiter key pre-set for this function
      \keys_set:nn {conmath / matrix } {delimiter = #3}
      \tl_if_novalue:nF {##1}
      {
        \keys_set:nn {conmath / matrix } {##1}
      }
      #2 {\l_@@_matrix_delim_tl} {##2}
      \group_end:
    }
  }{
    % warn if csname is taken
    \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
    {
      #1
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \pcvector,
%   \bcvector,
%   \Bcvector,
%   \vcvector,
%   \Vcvector,
%   \prvector,
%   \brvector,
%   \Brvector,
%   \vrvector,
%   \Vrvector,
% }
%   Now we define shorthands for all of the matrix types so that the user
%   does not have to specify |delimiter=|\meta{delim} every time.
%   We begin with the column vector.
%    \begin{macrocode}
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \pcvector \conmath_column_vector:nn {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \bcvector \conmath_column_vector:nn {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Bcvector \conmath_column_vector:nn {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vcvector \conmath_column_vector:nn {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vcvector \conmath_column_vector:nn {V}
%    \end{macrocode}
%   Now to the row vectors.
%    \begin{macrocode}
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \prvector \conmath_row_vector:nn {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \brvector \conmath_row_vector:nn {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Brvector \conmath_row_vector:nn {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vrvector \conmath_row_vector:nn {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vrvector \conmath_row_vector:nn {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \psmallcvector,
%   \bsmallcvector,
%   \Bsmallcvector,
%   \vsmallcvector,
%   \Vsmallcvector,
%   \psmallrvector,
%   \bsmallrvector,
%   \Bsmallrvector,
%   \vsmallrvector,
%   \Vsmallrvector
% }
%   We also define shorthands for the \cs{shortcvector} and \cs{shortrvector}
%   versions.
%    \begin{macrocode}
% column vectors
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \psmallcvector \conmath_column_smallvector:nn
  {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \bsmallcvector \conmath_column_smallvector:nn
  {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Bsmallcvector \conmath_column_smallvector:nn
  {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vsmallcvector \conmath_column_smallvector:nn
  {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vsmallcvector \conmath_column_smallvector:nn
  {V}
%
% row vectors
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \psmallrvector \conmath_row_smallvector:nn {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \bsmallrvector \conmath_row_smallvector:nn {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Bsmallrvector \conmath_row_smallvector:nn {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vsmallrvector \conmath_row_smallvector:nn {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vsmallrvector \conmath_row_smallvector:nn {V}


}{ % \bool_if:nTF \l_@@_predef_crvector_bool FALSE PATH
  \msg_info:nnnn {conmath} {load / disabling} {no-crvector}
  {
    commands~producing~row~and~column~vectors
  }
} % \bool_if:nTF \l_@@_predef_crvector_bool
%    \end{macrocode}
% \end{macro}
%
% Now to the (anti-)diagonal matrix shorthands,
% these are also guarded by a key value option.
%    \begin{macrocode}
\bool_if:nTF \l_@@_predef_matrix_bool
{
%    \end{macrocode}
% \begin{macro}{
%   \diagmat,
%   \antidiagmat,
%   \smalldiagmat,
%   \smallantidiagmat,
% }
%    \begin{macrocode}
\cs_if_free:NTF \diagmat
{
  \NewDocumentCommand \diagmat { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_diagonal_matrix:Vn \l_@@_matrix_delim_tl {#2}
    \group_end:
  }
}{
  \msg_warning:nnn {conmath} {matrix / already-defined-doc-cmd-skip}
  {
    \diagmat
  }
} % \cs_if_free:nTF \diagmat

\cs_if_free:NTF \antidiagmat
{
  \NewDocumentCommand \antidiagmat { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_antidiagonal_matrix:Vn \l_@@_matrix_delim_tl {#2}
    \group_end:
  }
}{
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \antidiagmat
  }
} % \cs_if_free:nTF \antidiagmat

\cs_if_free:NTF \smalldiagmat
{
  \NewDocumentCommand \smalldiagmat { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_diagonal_smallmatrix:Vn \l_@@_matrix_delim_tl {#2}
    \group_end:
  }
}{
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smalldiagmat
  }
}

\cs_if_free:NTF \smallantidiagmat
{
  \NewDocumentCommand \smallantidiagmat { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_antidiagonal_smallmatrix:Vn \l_@@_matrix_delim_tl {#2}
    \group_end:
  }
}{
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smallantidiagmat
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \@@_new_matrix_shorth_doc_cmd:NNn
% }
%   To provide several shorthands for delimited matrices,
%   we use a helper function to avoid code duplication.
%   \cs{@@_new_matrix_shorth_doc_cmd:Nn} takes two arguments:
%   \begin{arguments}
%     \item The \meta{csname} to define
%     \item The \meta{csname} of the matrix function to use,
%           which should have the signature |Vn|.
%      \item The \enquote{predefined} delimiter of this version
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_matrix_shorth_doc_cmd:NNn
{
  \cs_if_free:NTF #1
  {
    \NewDocumentCommand #1 { o m }
    {
      \group_begin:
      \tl_if_empty:nF {#3}
      {
        \keys_set:nn { conmath / matrix }
        {
          delimiter = #3
        }
      } % \tl_if_empty:nF {#3}
      \tl_if_novalue:nF {##1}
      {
        \keys_set:nn { conmath / matrix } {##1}
      }
      #2 \l_@@_matrix_delim_tl {##2}
      \group_end:
    }
  }{
    \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
    {
      #1
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% We now define the shorthand commands with predefined delimiters.
% \begin{macro}{
%   \pdiagmat,
%   \bdiagmat,
%   \Bdiagmat,
%   \vdiagmat,
%   \Vdiagmat,
% }
%   We begin with the regular diagonal matrix
%    \begin{macrocode}
\@@_new_matrix_shorth_doc_cmd:NNn \pdigmat \conmath_diagonal_matrix:Vn {p}
\@@_new_matrix_shorth_doc_cmd:NNn \bdigmat \conmath_diagonal_matrix:Vn {b}
\@@_new_matrix_shorth_doc_cmd:NNn \Bdigmat \conmath_diagonal_matrix:Vn {B}
\@@_new_matrix_shorth_doc_cmd:NNn \vdigmat \conmath_diagonal_matrix:Vn {v}
\@@_new_matrix_shorth_doc_cmd:NNn \Vdigmat \conmath_diagonal_matrix:Vn {V}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \pantidiagmat,
%   \bantidiagmat,
%   \Bantidiagmat,
%   \vantidiagmat,
%   \Vantidiagmat,
%  }
%   Now for the anti-diagonal matrix commands.
%    \begin{macrocode}
\@@_new_matrix_shorth_doc_cmd:NNn \pantidiagmat
  \conmath_antidiagonal_matrix:Vn {p}
\@@_new_matrix_shorth_doc_cmd:NNn \bantidiagmat
  \conmath_antidiagonal_matrix:Vn {b}
\@@_new_matrix_shorth_doc_cmd:NNn \Bantidiagmat
  \conmath_antidiagonal_matrix:Vn {B}
\@@_new_matrix_shorth_doc_cmd:NNn \vantidiagmat
  \conmath_antidiagonal_matrix:Vn {v}
\@@_new_matrix_shorth_doc_cmd:NNn \Vantidiagmat
  \conmath_antidiagonal_matrix:Vn {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \psmalldiagmat,
%   \bsmalldiagmat,
%   \Bsmalldiagmat,
%   \vsmalldiagmat,
%   \Vsmalldiagmat,
% }
%   We continue with the inline math versions based on the \env{smallmatrix*}
%   environment.
%    \begin{macrocode}
\@@_new_matrix_shorth_doc_cmd:NNn \psmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {p}
\@@_new_matrix_shorth_doc_cmd:NNn \bsmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {b}
\@@_new_matrix_shorth_doc_cmd:NNn \Bsmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {B}
\@@_new_matrix_shorth_doc_cmd:NNn \vsmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {v}
\@@_new_matrix_shorth_doc_cmd:NNn \Vsmalldiagmat
  \conmath_diagonal_smallmatrix:Vn {V}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{
%   \psmallantidiagmat,
%   \bsmallantidiagmat,
%   \Bsmallantidiagmat,
%   \vsmallantidiagmat,
%   \Vsmallantidiagmat,
% }
% We provide also anti-diagonal versions of the small matrices.
%    \begin{macrocode}
\@@_new_matrix_shorth_doc_cmd:NNn \psmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {p}
\@@_new_matrix_shorth_doc_cmd:NNn \bsmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {b}
\@@_new_matrix_shorth_doc_cmd:NNn \Bsmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {B}
\@@_new_matrix_shorth_doc_cmd:NNn \vsmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {v}
\@@_new_matrix_shorth_doc_cmd:NNn \Vsmallantidiagmat
  \conmath_antidiagonal_smallmatrix:Vn {V}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
}{ % \bool_if:nTF \l_@@_predef_matrix_bool FALSE BRANCH
  \msg_info:nnnn {conmath} { load / disabling } { no-matrix }
  {
    (anti-)diagonal~matrix~commands
  }
} % \bool_if:nTF \l_@@_predef_matrix_bool
%     \end{macrocode}
%
%
% \subsection{Shorthand Macros for Absolute Value and Norm}
% \label{sec:impl-abs-shorthands}
%
% We first declare another warning message to inform the user of the case that,
% the \meta{csnames} are already taken.
%    \begin{macrocode}
\msg_new:nnnn { conmath } { abs-shorth / csname-already-defined-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~declaration~of~paired~delimiter~\msg_line_context:.\\
  Use~package~option~'no-abs-shorthands'~to~disable~the~paired\\
  delimiter~shorthands.
}{
  The~control~sequence~'#1'~has~already~been\\
  defined~by~something~else.\\
  I~am~refusing~to~overwrite~its~existing~definition~and~instead~avoid\\
  declaring~a~paired~delimiter.\\
}
%    \end{macrocode}
%
%
% As with the other parts these macros may be conditionally disabled.
%    \begin{macrocode}
\bool_if:NTF \l_@@_predef_abs_bool
{
%    \end{macrocode}
% \begin{macro}{\abs,\norm}
% These macros provide shorthands for \(\abs{\meta{content}}\)
% and \(\norm{\meta{content}}\).
%    \begin{macrocode}
\cs_if_free:NTF \abs
{
  \DeclarePairedDelimiter \abs {\lvert} {\rvert}
}{
  % warn if the csname is taken
  \msg_warning:nnn { conmath } { abs-shorth / csname-already-defined-skip }
    {\abs}
} % \cs_if_free:NTF \abs

\cs_if_free:NTF \norm
{
  \DeclarePairedDelimiter \norm {\lVert} {\rVert}
}{
  % warn if csname is already taken
  \msg_warning:nnn { conmath } { abs-shorth / csname-already-defined-skip }
    {\norm}
} % \cs_if_free:NTF
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
}{
  \msg_info:nnnn {conmath} {load / disabling} {no-abs-shorthands}
  {
    '\abs'~and~'\norm'~macros
  }
} % End of the conditional
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{implementation}

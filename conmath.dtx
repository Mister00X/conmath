% \iffalse meta-comment
%
% Copyright (C) 2024 Marcel Ilg
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%
%      https://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status ‘maintained’.
%
% The Current Maintainer of this work is Marcel Ilg.
%
% This work consists of the files listed in MANIFEST.md.
% \fi
%
% \iffalse
%
%<*driver>
% Generated by ctanbib
\begin{filecontents}[overwrite]{\jobname.bib}
@preamble{ "\providecommand\ctanbibpkgname[1]{\textsl{#1}}" }
@manual{amsmath,
  title = {The \ctanbibpkgname{amsmath} package},
  subtitle = {AMS mathematical facilities for LaTeX},
  author = {{The LaTeX Project Team}},
  url = {https://ctan.org/pkg/amsmath},
  urldate = {2024-06-08},
  date = {2023-05-13},
  version = {2.17o},
}

@preamble{ "\providecommand\ctanbibpkgname[1]{\textsl{#1}}" }
@manual{bm,
  title = {The \ctanbibpkgname{bm} package},
  subtitle = {Access bold symbols in maths mode},
  author = {Carlisle, David and Mittelbach, Frank and {The LaTeX Project Team}},
  url = {https://ctan.org/pkg/bm},
  urldate = {2024-06-08},
  date = {2023-12-19},
  version = {1.2f},
}

@preamble{ "\providecommand\ctanbibpkgname[1]{\textsl{#1}}" }
@manual{mathtools,
  title = {The \ctanbibpkgname{mathtools} package},
  subtitle = {Mathematical tools to use with amsmath},
  author = {Høgholm, Morten and Madsen, Lars and Robertson, Will and Wright, Joseph and {The LaTeX Project Team}},
  url = {https://ctan.org/pkg/mathtools},
  urldate = {2024-06-08},
  date = {2024-03-11},
  version = {1.30},
}
\end{filecontents}
\documentclass[full]{l3doc}

\usepackage[american]{babel}

\usepackage[style=alphabetic]{biblatex}
\addbibresource{\jobname.bib}

\usepackage[bm]{conmath}
\conmathsetup{arrownabla}

% renew the ctanbibpkgname command
\NewDocumentCommand\ctanbibpkgname{m}{\pkg{#1}}

\begin{document}
  \DocInput{conmath.dtx}
\end{document}
%</driver>
% \fi
%
% ^^X Get the package version name etc.
% \GetFileInfo{conmath.sty}
%
% \changes{v0.0.1}{2024-01-09}{Initial version}
%
% \title{The \textsf{conmath} package\thanks{This document coresponds to
%   \textsf{conmath}~\fileversion, dated \filedate.}}
% \author{Marcel Ilg\thanks{\texttt{mister01x (at) web (dot) de}}}
%
% \maketitle
% \begin{abstract}
% \end{abstract}
% \tableofcontents
% \begin{documentation}
% \section{Introduction}
% \label{sec:intro}
%
% \end{documentation}
% \begin{implementation}
% \section{Implementation}
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Set the internal prefix for this package so that \pkg{DocStrip} knows what to
% do.
%    \begin{macrocode}
%<@@=conmath>
%    \end{macrocode}
%
% \subsection{Initial Setup}
%
% First set the required version of \LaTeX{},
% we need at least
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2022-06-01]
%    \end{macrocode}
% for key-value option handling, \pkg{xparse}-like document commands
% and hooks.
%
% Then identify this package as \pkg{conmath}.
%    \begin{macrocode}
\ProvidesExplPackage{conmath}
  {2024-01-09}{0.1.0}{Convenience Math Macros}
%    \end{macrocode}
%
% ^^X Debugging switch
% \iffalse
% \debug_on:n {}
% \fi
% \subsection{Key-value interfaces}
% \label{sec:key-val}
% To make use of key-value interfaces we need to define a few keys.
%
% \subsubsection{Package load time options}
% \label{sec:load-time-options}
%
% To allow for the conditional definition of macros at load time
% we define a few keys.
%
% But before doing so we define a few messages to write the package options to
% the log file.
% One message to issue if the \texttt{bm} option has been given:
%    \begin{macrocode}
\msg_new:nnn { conmath } {load / bm}
{
  Option~'bm'~given.\\
  Loading~the~bm~package~\msg_line_context:.
}
%    \end{macrocode}
% And a more generic message to issue for the other options,
% which all disable certain parts of the library.
%    \begin{macrocode}
\msg_new:nnn {conmath} { load / disabling }
{
  Option~'#1'~given.\\
  Disabling~#2~\msg_line_context:.
}
%    \end{macrocode}
%    \begin{macrocode}
\keys_define:nn { conmath / load }
{
%    \end{macrocode}
% We provide an option to conditionally load the \pkg{bm}-package~\autocite{bm}
% to provide better looking bold symbols.
%    \begin{macrocode}
  bm .code:n = {
    \msg_info:nn {conmath} {load / bm}
    \RequirePackage{bm}
  },
  bm .value_forbidden:n = true,
%    \end{macrocode}
% \begin{variable}{
%   \l_@@_predef_vector_op_bool,
%   \l_@@_predef_operators_bool,
%   \l_@@_predef_crvector_bool,
%   \l_@@_predef_abs_bool,
% }
% Then we define options for en-/disabling predefined macros of this package
% to avoid name clashes.
%    \begin{macrocode}
  no-vector .bool_set_inverse:N = \l_@@_predef_vector_op_bool,
  no-vector .default:n = true,
  no-vector .initial:n = false,
  no-vector .usage:n = load,
  no-operators .bool_set_inverse:N = \l_@@_predef_operators_bool,
  no-operators .default:n = true,
  no-operators .initial:n = false,
  no-operators .usage:n = load,
  no-abs-shorthands .bool_set_inverse:N = \l_@@_predef_abs_bool,
  no-abs-shorthands .default:n = true,
  no-abs-shorthands .initial:n = false,
  no-abs-shorthands .usage:n = load,
%    \end{macrocode}
% The variables \cs{l_@@_predef_vector_op_bool}, \cs{l_@@_predef_operators_bool}
% \cs{l_@@_predef_abs_bool},
% and \cs{l_@@_predef_crvector_bool}
% control if the predefined macros
% for vector calculus, delimited operators,
% the row and column vectors,
% and the shorthands for absolute value
% and norm shall be defined.
% \end{variable}
%    \begin{macrocode}
  nopredef .multichoice:,
  nopredef / operators .meta:nn = { conmath / load }
  {
    no-operators = true
  },
  nopredef / vector .meta:nn = { conmath / load }
  {
    no-vector = true
  },
  nopredef / abs .meta:nn = { conmath / load }
  {
    no-abs-shorthands = true,
  },
  nopredef / all .meta:nn = { conmath / load }
  {
    no-operators = true,
    no-vector = true,
    no-abs-shorthands = true
  },
  nopredef .usage:n = load,
%    \end{macrocode}
% Unknown package options get passed to \pkg{mathtools}.
%    \begin{macrocode}
  unknown .code:n = {\PassOptionsToPackage{\CurrentOption}{mathtools}},
  unknown .usage:n = load,
}
%    \end{macrocode}
%
%
% \subsubsection{Keys controlling appearance}
% \label{sec:keys-appearance}
%
% First define keys for the vector calculus macros.
%    \begin{macrocode}
\keys_define:nn { conmath }
{
%    \end{macrocode}
% First we define keys for use with the gradient and gradient based operators.
% \begin{variable}{
%   \l_@@_nabla_tl,
%   \l_@@_nabla_arrow_bool,
%   \l_@@_nabla_arrow_bold_bool,
%   \l_@@_grad_op_tl,
% }
%    \begin{macrocode}
  % Symbol to use for the nabla
   nabla .tl_set:N = \l_@@_nabla_tl,
   nabla .initial:n = {\nabla},
   nabla .value_required:n = true,
   % shall the nabla have an arrow over it
   arrownabla .bool_set:N = \l_@@_nabla_arrow_bool,
   arrownabla .default:n = {true},
   arrownabla .initial:n = {false},
   % shall the nabla be bold
   boldnabla .bool_set:N = \l_@@_nabla_bold_bool,
   boldnabla .default:n = {true},
   boldnabla .initial:n = {false},
%    \end{macrocode}
% The symbol to use as \enquote{nabla} is stored in \cs{l_@@_nabla_tl}.
% The variables \cs{l_@@_nabla_arrow_bool} and \cs{l_@@_nabla_bold_bool}
% determine if the nabla-symbol shall have an arrow over itself and/or be bold
% respectively.
%
% We also provide an override for the gradient operator
%    \begin{macrocode}
   % Symbol to use for the gradient operator
   grad-op .tl_set:N = \l_@@_grad_op_tl,
   grad-op .value_required:n = true,
%    \end{macrocode}
% The variable \cs{l_@@_grad_op_tl} contains a user provided token list to
% overwrite the built-in gradient operator of the package.
% \end{variable}
%
% \begin{variable}{
%   \l_@@_laplacian_symb_tl,
%   \l_@@_laplacian_delta_bool,
%   \l_@@_laplacian_arrow_bool,
%   \l_@@_laplacian_tl,
% }
% Then we define keys for the laplacian.
%    \begin{macrocode}
   % Symbol to use for the laplacian
   laplacian-symb .tl_set:N = \l_@@_laplacian_symb_tl,
   laplacian-symb .initial:n = {\l_@@_nabla_tl},
   % shall the Laplace operator be a delta
   delta-laplace .bool_set:N = \l_@@_laplacian_delta_bool,
   delta-laplace .initial:n = {false},
   % shall the laplace operator have an arrow over itself
   arrowlaplace .bool_set:N = \l_@@_laplacian_arrow_bool,
   arrowlaplace .default:n = {true},
   arrowlaplace .initial:n = {false},
   % overwrite the laplace operator
   laplacian .tl_set:N = \l_@@_laplacian_tl,
   laplacian .value_required:n = true,
}
%    \end{macrocode}
% The token list variable \cs{l_@@_laplacian_symb_tl} stores the tokens to be
% used for the Laplace operator.
% The boolean variable \cs{l_@@_laplacian_delta_bool}
% determines if a delta should be used instead
% of \(\laplacian\) for the laplacian symbol.
% If the boolean variable \cs{l_@@_laplacian_arrow_bool} a small arrow will be
% placed over the Laplace operator symbol.
% If the user wants to overwrite the symbol used for the Laplacian,
% the user provided list of tokens is stored in the variable
% \cs{l_@@_laplacian_tl}.
% \end{variable}
%
% \begin{variable}{
% \l_@@_matrix_delim_tl,
% \l_@@_matrix_fill_tl,
% }
% Then we define some keys for the matrix based environments:
%    \begin{macrocode}
\keys_define:nn { conmath / matrix }
{
  delimiter .tl_set:N = \l_@@_matrix_delim_tl,
  delimiter .initial:n = {},
  fill .tl_set:N = \l_@@_matrix_fill_tl,
  fill .initial:n = {},
}
%    \end{macrocode}
% The keys \verb|delimiter| and \verb|fill| set the variables
% \cs{l_@@_matrix_delim_tl} and \cs{l_@@_matrix_fill_tl} respectively.
% \cs{l_@@_matrix_delim_tl} determines the delimiter in use to surround
% matrices and \cs{l_@@_matrix_fill_tl} determines the fill values of the
% \cs{diag}, \cs{smalldiag}, \cs[no-index]{Xdiag} and \cs[no-index]{Xsmalldiag}
% commands, which are used for non-diagonal matrix entries.
% \end{variable}
%
% \subsubsection{Functions for Setting Options}
% \label{sec:option-setters}
%
%
% Now we define a function for setting the options within the document
% \begin{macro}{\conmath_setup:n}
%    \begin{macrocode}
\cs_new_protected:Nn \conmath_setup:n
{
  \keys_set:nn {conmath} {#1}
}
%    \end{macrocode}
% \end{macro}
%
% Additionally we provide the user with a version of this command.
% \begin{macro}{\conmathsetup}
%    \begin{macrocode}
\DeclareDocumentCommand \conmathsetup {m}
{
  \conmath_setup:n {#1}
}
%    \end{macrocode}
% \end{macro}
% We also need a function for setting the package load time options.
% This function should set all given values for all key families
% and pass unknown options to mathtools.
% \begin{macro}{\@@_load_time_setup:}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_load_time_setup:
{
  \ProcessKeyOptions[ conmath / load ]
}
%    \end{macrocode}
% \end{macro}
%
% ^^X SUBSECTION: Package Initialization
% \subsection{Package Initialization}
% \label{sec:init}
%
% We now \enquote{initialize} the package by processing the package options,
% all unknown options are passed to \pkg{mathtools}~\autocite{mathtools},
% which is loaded afterwards.
% Because certain \pkg{mathtools}-features are needed by this package,
% we need to require a version of at least 2004/06/05.
% As explained in section~\ref{sec:load-time-options} this may also load \pkg{bm}
% if the \verb|bm| package option has been given.
%    \begin{macrocode}
\@@_load_time_setup:

\RequirePackage{mathtools}[2004/06/05]
%    \end{macrocode}
%
%
% \subsection{Macros Producing Matrices and Vectors}
% \label{sec:impl-matr-vec}
%
% \subsubsection{Producing Row and Column Vectors}
%
% The functions in this section are used to generate row and column vectors
% utilizing \pkg{mathtools}~\autocite{mathtools} \env{matrix*} and
% \env{smallmatrix*} environments.
%
% \begin{variable}{\l_@@_vector_entries_seq}
%   For generating row or column vectors it is necessary to store the entries
%   inside a variable. \cs{l_@@_vector_entries_seq} is used for this purpose.
%    \begin{macrocode}
\seq_new:N \l_@@_vector_entries_seq
%    \end{macrocode}
% \end{variable}
%
% Then we need a function for formatting the actual entries of the vector.
% We need two version one for the row vector and one for the column vector
% version.
% \begin{macro}{
%   \@@_seq_to_column_vector:N,
%   \@@_seq_to_row_vector:N
% }
%   These functions take one argument
%   \begin{arguments}
%     \item A sequence which should be converted to the contents of the single
%     column/row matrix.
%   \end{arguments}
%   They format the input suitable to be put inside a \env{matrix*} environment.
% We begin with the column vector version.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_seq_to_column_vector:N
{
  \seq_use:Nn #1 {\\}
}
%    \end{macrocode}
% Then we get to the row vector.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \@@_seq_to_row_vector:N
{
  \seq_use:Nn #1 {&}
}
%    \end{macrocode}
% \end{macro}
%
% In the next step we construct the single row/column matrix from the user
% provided input.
% \begin{macro}{
%   \conmath_column_vector:nn,
%   \conmath_row_vector:nn,
% }
%   The two commands \cs{conmath_column_vector:n} and \cs{conmath_row_vector:n}
%   construct the matrix, they both take two arguments.
%   \begin{arguments}
%     \item The delimiter specifier.
%
%     This should be one of the prefixes of the \env{\meta{prefix}matrix*},
%     environments.
%
%     Another possibility is to issue |small| as this parameter to get
%     an inline matrix.
%
%     \item The comma separated contents of the matrix.
%   \end{arguments}
%     \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_column_vector:nn
{
  \seq_clear:N \l_@@_vector_entries_seq
  \seq_set_from_clist:Nn \l_@@_vector_entries_seq {#2}

  \begin{#1 matrix*} [\l_@@_matrix_align_tl]
    \@@_seq_to_column_vector:N \l_@@_vector_entries_seq
  \end{#1 matrix*}
}

\cs_new_protected_nopar:Nn \conmath_row_vector:nn
{
  \seq_clear:N \l_@@_vector_entries_seq
  \seq_set_from_clist:Nn \l_@@_vector_entries_seq {#2}

  \begin{#1matrix*}[\l_@@_matrix_align_tl]
    \@@_seq_to_row_vector:N \l_@@_vector_entries_seq
  \end{#1matrix*}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \conmath_column_smallvector:nn,
%   \conmath_row_smallvector:nn
% }
%   To make the code more readable, we define functions specifically for
%   creating row and column vectors using the \env{smallmatrix*} family of
%   environments. These functions take the same arguments as the non-small
%   versions above.
%    \begin{macrocode}
\cs_new_protected_nopar:Nn \conmath_column_smallvector:nn
{
  \conmath_column_vector:nn {#1 small} {#2}
}

\cs_new_protected_nopar:Nn \conmath_row_smallvector:nn
{
  \conmath_row_vector:nn {#1 small} {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Document Level Commands}
% \label{sec:mat-doc-lvl-cmds}
%
% \NB{MI}{Guard these macros also behind a key-value option}
%
% Now we define document level commands for the previously defined
% functions.
%
% But before we do so we define a message to be issued in case the targeted
% \meta{csname} is already defined elsewhere.
%    \begin{macrocode}
\msg_new:nnnn { conmath } { matrix / already-defined-doc-cmd-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~definition~\msg_line_context:.
}
{
  The~control~sequence~'#1'~has~already\\
  been~defined~by~some~other~package.\\
  And~I~am~refusing~to~overwrite~the~existing~definition,\\
  therefore~I~am~skipping~the~definition~of~this~command.
}
%    \end{macrocode}
% We begin with the row and column vector functions.
% As with the other document level commands, we guard the definitions
% with a key value option, so that the user can disable them.
%    \begin{macrocode}
\bool_if:nTF \l_@@_predef_crvector_bool
{
%    \end{macrocode}
% \begin{macro}{
%   \cvector,
%   \rvector,
%   \smallcvector,
%   \smallrvector
% }
%    \begin{macrocode}
% First we define the document level command for the bare column vector
\cs_if_free:NTF \cvector
{
  \NewDocumentCommand \cvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_column_vector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % issue a warning message if the csname is already taken.
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \cvector
  }
} % \cs_if_free:NTF \cvector
%    \end{macrocode}
% and the row vector.
%    \begin{macrocode}
\cs_if_free:NTF \rvector
{
  \NewDocumentCommand \rvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_row_vector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % warn if csname is already taken
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip}
  {
    \rvector
  }
} % \cs_if_free:NTF \rvector
%    \end{macrocode}
% Then we define the smaller inline versions of those commands.
%    \begin{macrocode}
\cs_if_free:NTF \smallcvector
{
  \NewDocumentCommand \smallcvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn {conmath / matrix} {#1}
    }
    \conmath_column_smallvector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % Issue a warning message if the csname is already taken
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smallcvector
  }
} % \cs_if_free:NTF \smallcvector

\cs_if_free:NTF \smallrvector
{
  \NewDocumentCommand \smallrvector { o m }
  {
    \group_begin:
    \tl_if_novalue:nF {#1}
    {
      \keys_set:nn { conmath / matrix } {#1}
    }
    \conmath_row_smallvector:nn {\l_@@_matrix_delim_tl} {#2}
    \group_end:
  }
}{
  % warn if csname is taken
  \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
  {
    \smallrvector
  }
}
%    \end{macrocode}
% \end{macro}
%
% Next we define several shorthands to for the commonly used delimiters,
% to avoid code duplication, we first create some helper functions which
% define those functions.
% \begin{macro}{
%   \@@_new_vector_shorth_doc_cmd:NNn
% }
%   The function \cs{@@_new_vector_shorth_doc_cmd} creates a new vector shorthand,
%   command. It takes three arguments:
%   \begin{arguments}
%     \item The \meta{csname} to be defined.
%     \item The \meta{function} to use for this shorthand.
%
%     This should be one of the
%     \cs[no-index]{conmath_\meta{type}_\meta{size}vector:nn}
%     like commands.
%
%     \item The \meta{delimiter} to use.
%
%      Usually one of |p|, |b|, |B|, |v|, |V|.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Nn \@@_new_vector_shorth_doc_cmd:NNn
{
  \cs_if_free:NTF #1
  {
    \NewDocumentCommand #1 { o m }
    {
      \group_begin:
      % set the delimiter key pre-set for this function
      \keys_set:nn {conmath / matrix } {delimiter = #3}
      \tl_if_novalue:nF {##1}
      {
        \keys_set:nn {conmath / matrix } {##1}
      }
      #2 {\l_@@_matrix_delim_tl} {##2}
      \group_end:
    }
  }{
    % warn if csname is taken
    \msg_warning:nnn { conmath } { matrix / already-defined-doc-cmd-skip }
    {
      #1
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \pcvector,
%   \bcvector,
%   \Bcvector,
%   \vcvector,
%   \Vcvector,
%   \prvector,
%   \brvector,
%   \Brvector,
%   \vrvector,
%   \Vrvector,
% }
%   Now we define shorthands for all of the matrix types so that the user
%   does not have to specify |delimiter=|\meta{delim} every time.
%   We begin with the column vector.
%    \begin{macrocode}
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \pcvector \conmath_column_vector:nn {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \bcvector \conmath_column_vector:nn {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Bcvector \conmath_column_vector:nn {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vcvector \conmath_column_vector:nn {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vcvector \conmath_column_vector:nn {V}
%    \end{macrocode}
%   Now to the row vectors.
%    \begin{macrocode}
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \prvector \conmath_row_vector:nn {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \brvector \conmath_row_vector:nn {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Brvector \conmath_row_vector:nn {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vrvector \conmath_row_vector:nn {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vrvector \conmath_row_vector:nn {V}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%   \psmallcvector,
%   \bsmallcvector,
%   \Bsmallcvector,
%   \vsmallcvector,
%   \Vsmallcvector,
%   \psmallrvector,
%   \bsmallrvector,
%   \Bsmallrvector,
%   \vsmallrvector,
%   \Vsmallrvector
% }
%   We also define shorthands for the \cs{shortcvector} and \cs{shortrvector}
%   versions.
%    \begin{macrocode}
% column vectors
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \psmallcvector \conmath_column_smallvector:nn
  {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \bsmallcvector \conmath_column_smallvector:nn
  {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Bsmallcvector \conmath_column_smallvector:nn
  {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vsmallcvector \conmath_column_smallvector:nn
  {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vsmallcvector \conmath_column_smallvector:nn
  {V}
%
% row vectors
% parenthesis
\@@_new_vector_shorth_doc_cmd:NNn \psmallrvector \conmath_row_smallvector:nn {p}
% brackets
\@@_new_vector_shorth_doc_cmd:NNn \bsmallrvector \conmath_row_smallvector:nn {b}
% braces
\@@_new_vector_shorth_doc_cmd:NNn \Bsmallrvector \conmath_row_smallvector:nn {B}
% single vert
\@@_new_vector_shorth_doc_cmd:NNn \vsmallrvector \conmath_row_smallvector:nn {v}
% double vert
\@@_new_vector_shorth_doc_cmd:NNn \Vsmallrvector \conmath_row_smallvector:nn {V}


}{ % \bool_if:nTF \l_@@_predef_crvector_bool FALSE PATH
  \msg_info:nnnn {conmath} {load / disabling} {no-crvector}
  {
    commands~producing~row~and~column~vectors
  }
} % \bool_if:nTF \l_@@_predef_crvector_bool
%    \end{macrocode}
% \end{macro}
%
% \subsection{Shorthand Macros for Absolute Value and Norm}
% \label{sec:impl-abs-shorthands}
%
% We first declare another warning message to inform the user of the case that,
% the \meta{csnames} are already taken.
%    \begin{macrocode}
\msg_new:nnnn { conmath } { abs-shorth / csname-already-defined-skip }
{
  Control~sequence~'#1'~is~already~defined.\\
  Skipping~declaration~of~paired~delimiter~\msg_line_context:.\\
  Use~package~option~'no-abs-shorthands'~to~disable~the~paired\\
  delimiter~shorthands.
}{
  The~control~sequence~'#1'~has~already~been\\
  defined~by~something~else.\\
  I~am~refusing~to~overwrite~its~existing~definition~and~instead~avoid\\
  declaring~a~paired~delimiter.\\
}
%    \end{macrocode}
%
%
% As with the other parts these macros may be conditionally disabled.
%    \begin{macrocode}
\bool_if:NTF \l_@@_predef_abs_bool
{
%    \end{macrocode}
% \begin{macro}{\abs,\norm}
% These macros provide shorthands for \(\abs{\meta{content}}\)
% and \(\norm{\meta{content}}\).
%    \begin{macrocode}
\cs_if_free:NTF \abs
{
  \DeclarePairedDelimiter \abs {\lvert} {\rvert}
}{
  % warn if the csname is taken
  \msg_warning:nnn { conmath } { abs-shorth / csname-already-defined-skip }
    {\abs}
} % \cs_if_free:NTF \abs

\cs_if_free:NTF \norm
{
  \DeclarePairedDelimiter \norm {\lVert} {\rVert}
}{
  % warn if csname is already taken
  \msg_warning:nnn { conmath } { abs-shorth / csname-already-defined-skip }
    {\norm}
} % \cs_if_free:NTF
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
}{
  \msg_info:nnnn {conmath} {load / disabling} {no-abs-shorthands}
  {
    '\abs'~and~'\norm'~macros
  }
} % End of the conditional
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{implementation}
